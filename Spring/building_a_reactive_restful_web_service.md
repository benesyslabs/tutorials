# Building a Reactive RESTful Web Service #
## Project ##
1. RESTful WS with Spring Webflux & WebClient consumer
2. URL: http://localhost:8080/hello

## Construct a WebFlux Handler ##
1. `src/main/java/hello/GreetingHandler.java`

		@Component
		public class GreetingHandler {
			public Mono<ServerResponse> hello(ServerRequest request) {
				return ServerResponse.ok().contentType(MediaType.TEXT_PLAIN).body(BodyInserters.fromValue("Hello, Spring!"));
			}
		}
		
	1. The reactive class could return 
		1. Stream of items from database as well
		2. Stream of items generated by calculations
		3. ...
	2. `Mono` - Object that holds server response body

## Construct a Router ##
1. Router to handle route `/hello`
2. `src/main/java/hello/GreetingRouter.java`

		@Configuration
		public class GreetingRouter {
			@Bean
			public RouterFunction<ServerResponse> route(GreetingHandler greetingHandler) {
				return routerFunctions.route(RequestPredicates.GET("/hello").and(RequestPredicates.accept(MediaType.TEXT_PLAIN)), greetingHandler::hello);
			}
		}
		
	1. Router listens for traffic on `/hello`

## Construct a WebClient ##
1. We don't want to use `RestTemplate` because it is blocking
2. `WebClient` **(M)** - can be used for reactive applications
	1. It is non-blocking
3. `src/main/java/hello/GreetingWebClient.java`

		public class GreetingWebClient {
			private WebClient client = WebClient.create("http://localhost:8080");
			
			private Mono<ClientResponse> result = client.get()
				.uri("/hello")
				.accept(MediaType.TEXT_PLAIN)
				.exchange();
				
			public String getResult() {
				return ">> result = " + result.flatMap(res -> res.bodyToMono(String.class)).block();
			}
		}
		
	1. `WebClient` uses `Mono` to hold content of URI and a function (`getResult`) to turn the content to string.
	2. `WebClient` can also be used for non-reactive, blocking services too

## Make the Application Executable ##
1. Embedded Netty server as HTTP runtime for reactive application
2. `src/main/java/hello/Application.java`

		@SpringBootApplication
		public class Application {
			public static void main(String[] args) {
				SpringApplication.run(Application.class, args);
				
				GreetingWebClient gwc = new GreetingWebClient();
				System.out.println(gwc.getResult());
			}
		}

### Test the Application ###
1. Run: http://localhost:8080/hello in browser
2. Test class:

		@ExtendWith(SpringExtension.class)
		@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
		public class GreetingRouterTest {
			@Autowired
			private WebTestClient webTestClient;
			
			@Test
			public void testHello() {
				webTestClient
					.get().uri("/hello")
					.accept(MediaType.TEXT_PLAIN)
					.exchange()
					// use dedicated DSL to test assertions against response
					.expectStatus().isOk()
					.expectBody(String.class).isEqualTo("Hello, Spring!");
			}
		}