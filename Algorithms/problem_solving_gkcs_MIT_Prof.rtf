{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf610
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 General way to solve algorithm problems (From MIT Professor - Patrick Winston - Prof in AI)\
1. Define the problem (statement)\
	1. Extremely difficult in real life\
	2. Convert requirement into a definition\
	3. Example: Find all numbers between 1 to 1000 which only two factors including themselves\
		1. f(i) = 2 where 1 <= factor(i)  <= i\
			1. This is equivalent to finding prime numbers between 1 to 1000\
2. Representation (constraints)\
	1. Constraints need to be represented in problem statement (definition)\
3. Approach/ Strategy\
	1. Way of thinking: (not specific algorithm, data structures at this stage) - generic approach\
		1. Breaking into subparts - recursive\
		2. Solve for each element - iterative\
4. Algorithm (mathematical terms)\
	1. Specific data structures and algorithms\
		1. Persistent DS, \'85\
5. Experiment/ Analysis\
	1. Efficiency check (backtrack to previous steps if this is not good)\
	\
1. Works for long contests\
2. Short contests it is a little challenging}