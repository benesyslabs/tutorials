<map version="1.0.1">
<!-- To view this file, download free mind mapping software FreeMind from http://freemind.sourceforge.net -->
<node CREATED="1567047499480" ID="ID_848879358" MODIFIED="1567047509773" TEXT="Easy to Advanced Data Structures">
<node CREATED="1567047519719" ID="ID_1870705705" MODIFIED="1567047546195" POSITION="right" TEXT="Introduction">
<node CREATED="1567047547072" ID="ID_1482133181" MODIFIED="1567047556583" TEXT="Abstract data types Introduction">
<node CREATED="1567048146445" ID="ID_1527261415" MODIFIED="1567048151762" TEXT="Foundation of core concepts">
<node CREATED="1567048155289" ID="ID_1604713066" MODIFIED="1567048160996" TEXT="What is a Data Structure?">
<node CREATED="1567048161861" ID="ID_972709341" MODIFIED="1567048176522" TEXT="A data structure (DS) is a way of organizing data so that it can be used effectively">
<node CREATED="1567048176965" ID="ID_1760679641" MODIFIED="1567048192405" TEXT="Accessed, queried, updated quickly and easily"/>
</node>
</node>
<node CREATED="1567048196116" ID="ID_584157180" MODIFIED="1567048202869" TEXT="Why Data Structures?">
<node CREATED="1567048203081" ID="ID_1519000817" MODIFIED="1567048219734" TEXT="They are essential ingredients in constructing fast and powerful algorithms"/>
<node CREATED="1567048221883" ID="ID_1327740219" MODIFIED="1567048227994" TEXT="They help to manage and organize data">
<node CREATED="1567048251110" ID="ID_99980391" MODIFIED="1567048254493" TEXT="Natural way"/>
</node>
<node CREATED="1567048228829" ID="ID_1061542262" MODIFIED="1567048241121" TEXT="They make code cleaner and easier to understand">
<node CREATED="1567048266443" ID="ID_553087727" MODIFIED="1567048268513" TEXT="Side note">
<node CREATED="1567048271696" ID="ID_13629465" MODIFIED="1567048293870" TEXT="Good programmers know how and when to use which data structure">
<node CREATED="1567048297325" ID="ID_1870009713" MODIFIED="1567048336806" TEXT="Good data structure makes a distinction between mediocre product and outstanding product"/>
</node>
</node>
</node>
</node>
<node CREATED="1567048340253" ID="ID_1330546745" MODIFIED="1567048354017" TEXT="Abstract Data Types vs. Data Structures">
<node CREATED="1567048354444" ID="ID_1368365896" MODIFIED="1567048358830" TEXT="Abstract Data Type">
<node CREATED="1567049971952" ID="ID_1969241598" MODIFIED="1567050003576" TEXT="An abstract data type (ADT) is an abstraction of a data structure which provides only the interface to which a data structure must adhere to.">
<node CREATED="1567050068116" ID="ID_768531720" MODIFIED="1567050084249" TEXT="Example: ADT - mode of transportation from A to B">
<node CREATED="1567050086125" ID="ID_808806907" MODIFIED="1567050089933" TEXT="Walking">
<node CREATED="1567050105182" ID="ID_1810617131" MODIFIED="1567050112116" TEXT="analogy of DS"/>
</node>
<node CREATED="1567050090159" ID="ID_971404041" MODIFIED="1567050091748" TEXT="Biking">
<node CREATED="1567050101606" ID="ID_739859823" MODIFIED="1567050104294" TEXT="analogy of DS"/>
</node>
<node CREATED="1567050092053" ID="ID_354990631" MODIFIED="1567050094949" TEXT="Taking train">
<node CREATED="1567050095868" ID="ID_1379385249" MODIFIED="1567050100269" TEXT="analogy of DS"/>
</node>
</node>
<node CREATED="1567050376371" ID="ID_548337334" MODIFIED="1567050387992" TEXT="Defines only how a DS should behave and what methods should it have"/>
</node>
<node CREATED="1567050003840" ID="ID_446587686" MODIFIED="1567050032495" TEXT="The interface does not give any specific details about how something should be implemented or in what programming language."/>
<node CREATED="1567050120813" ID="ID_1290676435" MODIFIED="1567050122382" TEXT="Examples">
<node CREATED="1567050122748" ID="ID_1045354089" MODIFIED="1567050126702" TEXT="ADT">
<node CREATED="1567050134121" ID="ID_760062472" MODIFIED="1567050135590" TEXT="List"/>
<node CREATED="1567050136611" ID="ID_253734829" MODIFIED="1567050137542" TEXT="Queue"/>
<node CREATED="1567050138375" ID="ID_294273149" MODIFIED="1567050139085" TEXT="Map"/>
<node CREATED="1567050139706" ID="ID_171491451" MODIFIED="1567050142997" TEXT="Vehicle"/>
</node>
<node CREATED="1567050128059" ID="ID_446856430" MODIFIED="1567050132190" TEXT="Implementation (DS)">
<node CREATED="1567050144814" ID="ID_1475189516" MODIFIED="1567050154894" TEXT="List">
<node CREATED="1567050155402" ID="ID_860803046" MODIFIED="1567050158814" TEXT="Dynamic Array"/>
<node CREATED="1567050159020" ID="ID_472897415" MODIFIED="1567050161398" TEXT="Linked List"/>
</node>
<node CREATED="1567050162268" ID="ID_67161090" MODIFIED="1567050164839" TEXT="Queue">
<node CREATED="1567050165122" ID="ID_1810256365" MODIFIED="1567050171286" TEXT="Linked List based Queue"/>
<node CREATED="1567050171932" ID="ID_1177733064" MODIFIED="1567050175718" TEXT="Array based Queue"/>
<node CREATED="1567050176060" ID="ID_1952779168" MODIFIED="1567050180198" TEXT="Stack based Queue">
<node CREATED="1567050359923" ID="ID_961338755" MODIFIED="1567050366194" TEXT="Not very efficient but possible"/>
</node>
</node>
<node CREATED="1567050181613" ID="ID_1793641982" MODIFIED="1567050183093" TEXT="Map">
<node CREATED="1567050183462" ID="ID_1365477796" MODIFIED="1567050185959" TEXT="Tree Map"/>
<node CREATED="1567050186191" ID="ID_1801598759" MODIFIED="1567050194088" TEXT="Hash Map/ Hash Table"/>
</node>
<node CREATED="1567050195239" ID="ID_1360024543" MODIFIED="1567050197247" TEXT="Vehicle">
<node CREATED="1567050197523" ID="ID_603547195" MODIFIED="1567050200999" TEXT="Golf Cart"/>
<node CREATED="1567050201237" ID="ID_691978505" MODIFIED="1567050203646" TEXT="Bicycle"/>
<node CREATED="1567050203888" ID="ID_4544758" MODIFIED="1567050207198" TEXT="Smart Car"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047558304" ID="ID_1539145981" MODIFIED="1567047567049" TEXT="Understanding time/space complexity">
<node CREATED="1567050583744" ID="ID_634634" MODIFIED="1567050602140" TEXT="Used to understand the performance of the DSs"/>
<node CREATED="1567050606281" ID="ID_346096629" MODIFIED="1567050610864" TEXT="Complexity Analysis">
<node CREATED="1567050611192" ID="ID_978437048" MODIFIED="1567050631057" TEXT="As programmers, we often find ourselves asking the same two questions over and over agian:">
<node CREATED="1567050634553" ID="ID_1708263559" MODIFIED="1567050669401">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      How much <b>time</b>&#160;does this algorithm need to finish?
    </p>
  </body>
</html></richcontent>
<font NAME="SansSerif" SIZE="12"/>
<node CREATED="1567050733584" ID="ID_932859777" MODIFIED="1567050739412" TEXT="Extreme case">
<node CREATED="1567050739618" ID="ID_362957" MODIFIED="1567050756496" TEXT="If program takes lifetime of universe to finish then it is bad"/>
</node>
</node>
<node CREATED="1567050673178" ID="ID_1178122761" MODIFIED="1567050702733">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      How much <b>space</b>&#160;does this algorithm need for its computation?
    </p>
  </body>
</html></richcontent>
<node CREATED="1567050765766" ID="ID_1025606052" MODIFIED="1567050768525" TEXT="Extreme case">
<node CREATED="1567050768725" ID="ID_1218753379" MODIFIED="1567050785870" TEXT="If program data takes all the bytes in all the files in the internet then it is bad"/>
</node>
</node>
</node>
<node CREATED="1567050799455" ID="ID_712791161" MODIFIED="1567050803550" TEXT="Big-O Notation">
<node CREATED="1567050807911" ID="ID_806542766" MODIFIED="1567050837545" TEXT="Big-O Notation gives an upper bound of the complexity in the worst case, helping to quantify performance as the input size becomes ararbitrarily large.">
<node CREATED="1567050910294" ID="ID_1532968674" MODIFIED="1567050918417" TEXT="It tells us the worst case">
<node CREATED="1567050924052" ID="ID_965193666" MODIFIED="1567050928423" TEXT="Example: Sorting">
<node CREATED="1567050928698" ID="ID_676568122" MODIFIED="1567050937460" TEXT="Assume input is the worst possible arrangement"/>
</node>
<node CREATED="1567050947540" ID="ID_1767353782" MODIFIED="1567050955080" TEXT="Exampe: Un-ordered list of numbers">
<node CREATED="1567050955343" ID="ID_584022651" MODIFIED="1567050962191" TEXT="Search for a number">
<node CREATED="1567050962535" ID="ID_1902306706" MODIFIED="1567050969583" TEXT="If number is last element or does not exist">
<node CREATED="1567050973886" ID="ID_1662335772" MODIFIED="1567050975880" TEXT="O(n)">
<node CREATED="1567050977582" ID="ID_1984585657" MODIFIED="1567050982960" TEXT="Need to traverse every element"/>
</node>
</node>
</node>
</node>
<node CREATED="1567050991761" ID="ID_909361956" MODIFIED="1567050994007" TEXT="Space">
<node CREATED="1567050994394" ID="ID_35974909" MODIFIED="1567051010757" TEXT="Worst amount of space possible"/>
</node>
</node>
<node CREATED="1567051022092" ID="ID_14313874" MODIFIED="1567051038713" TEXT="It tells how does the algorithm perform when the input is arbitrarily large">
<node CREATED="1567051038997" ID="ID_1622314018" MODIFIED="1567051047923" TEXT="Or grows to be arbitrarliy large"/>
<node CREATED="1567051057206" ID="ID_1230805795" MODIFIED="1567051065795" TEXT="We need to ignore constants and multiplicative factors"/>
</node>
<node CREATED="1567052115202" ID="ID_531484791" MODIFIED="1567052118690" TEXT="Big-O Notation">
<node CREATED="1567052118961" ID="ID_1355543050" MODIFIED="1567052132942" TEXT="n - The size of the input"/>
<node CREATED="1567052133184" ID="ID_1593801299" MODIFIED="1567052146005" TEXT="Compexities ordered in from smallest to largest">
<node CREATED="1567052146758" ID="ID_381616594" MODIFIED="1567052150821" TEXT="Constant Time: O(1)"/>
<node CREATED="1567052151250" ID="ID_607809622" MODIFIED="1567052158476" TEXT="Logarithmic Time: O(log(n))"/>
<node CREATED="1567052158995" ID="ID_543677270" MODIFIED="1567052163828" TEXT="Linear Time: O(n)"/>
<node CREATED="1567052164107" ID="ID_846709647" MODIFIED="1567052173734" TEXT="Linearithmic Time: O(nlog(n))"/>
<node CREATED="1567052174346" ID="ID_25020748" MODIFIED="1567052181765" TEXT="Quadratic Time: O(n^2)"/>
<node CREATED="1567052182091" ID="ID_1538719926" MODIFIED="1567052189318" TEXT="Cubic Time: O(n^3)"/>
<node CREATED="1567052189572" ID="ID_795812748" MODIFIED="1567052200939" TEXT="Exponential Time: O(b^n), b &gt; 1"/>
<node CREATED="1567052201302" ID="ID_1716108746" MODIFIED="1567052208222" TEXT="Factorial Time: O(n!)"/>
</node>
<node CREATED="1567483342098" ID="ID_506727581" MODIFIED="1567483345986" TEXT="Big-O Properties">
<node CREATED="1567483347275" ID="ID_1661548267" MODIFIED="1567483352859" TEXT="O(n + c) = O(n)">
<node CREATED="1567483508645" ID="ID_1680707201" MODIFIED="1567483519194" TEXT="adding c to infinity it is infinity"/>
</node>
<node CREATED="1567483357175" ID="ID_1737777107" MODIFIED="1567483366028" TEXT="O(cn) = O(n), c &gt; 0">
<node CREATED="1567483521283" ID="ID_439513698" MODIFIED="1567483536549" TEXT="multiplying by c to infinity is infinity"/>
</node>
</node>
<node CREATED="1567483384611" ID="ID_1355655522" MODIFIED="1567483388292" TEXT="Big-O Example">
<node CREATED="1567483388532" ID="ID_1512523692" MODIFIED="1567483407604" TEXT="Let f be a function that describes the running time of a particular algorithm for an input of size n:">
<node CREATED="1567483407929" ID="ID_1986830200" MODIFIED="1567483428430" TEXT="f(n) = 7log(n)^3 + 15n^2 + 2n^3 + 8">
<node CREATED="1567483429113" ID="ID_122976438" MODIFIED="1567483436757" TEXT="O(f(n)) = O(n^3)"/>
</node>
</node>
</node>
<node CREATED="1567483469454" ID="ID_715997094" MODIFIED="1567483480241" TEXT="We are only interested in what happens when n tends to infinity"/>
<node CREATED="1567483569081" ID="ID_1386628664" MODIFIED="1567483570577" TEXT="Examples">
<node CREATED="1567483570831" ID="ID_1783177980" MODIFIED="1567483620147">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      a := 1
    </p>
    <p>
      b := 2
    </p>
    <p>
      c := a + 5 * b
    </p>
    <p>
      
    </p>
    <p>
      i := 0
    </p>
    <p>
      While i &lt; 11 Do
    </p>
    <p>
      &#160;&#160;&#160;&#160;i = i + 1
    </p>
  </body>
</html></richcontent>
<node CREATED="1567483622032" ID="ID_1489138490" MODIFIED="1567483624555" TEXT="O(1)">
<node CREATED="1567483625320" ID="ID_966436955" MODIFIED="1567483629394" TEXT="Does not depend on n"/>
</node>
</node>
<node CREATED="1567483638428" ID="ID_1879236817" MODIFIED="1567483702462">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      i := 0
    </p>
    <p>
      While i &lt; n Do
    </p>
    <p>
      &#160;&#160;&#160;&#160;i = i + 1
    </p>
    <p>
      
    </p>
    <p>
      f(n) = n
    </p>
    <p>
      O(f(n)) = O(n)
    </p>
    <p>
      
    </p>
    <p>
      i := 0
    </p>
    <p>
      While i &lt; n Do
    </p>
    <p>
      &#160;&#160;&#160;&#160;i = i + 3
    </p>
    <p>
      
    </p>
    <p>
      f(n) = n/3
    </p>
    <p>
      O(f(n)) = O(n)
    </p>
  </body>
</html></richcontent>
</node>
<node CREATED="1567483751485" ID="ID_517940471" MODIFIED="1567483781346" TEXT="Both of the following run in quadratic time. The first may be obvious since n work done n times is n * n = O(n^2), but what about hte second one?">
<node CREATED="1567483781691" ID="ID_1437914013" MODIFIED="1567483815840">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      For (i := 0; i &lt; n; i = i + 1)
    </p>
    <p>
      &#160;&#160;&#160;&#160;For (j := 0; j &lt; n; j = j + 1)
    </p>
  </body>
</html></richcontent>
<node CREATED="1567483816908" ID="ID_367307686" MODIFIED="1567483833128" TEXT="f(n) = n * n = n^2, O(f(n)) = O(n^2)"/>
</node>
<node CREATED="1567483835704" ID="ID_1029876442" MODIFIED="1567483867606">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      For (i := 0; i &lt; n; i = i + 1)
    </p>
    <p>
      &#160;&#160;&#160;&#160;For (j := i; j &lt; n; j = j + 1)
    </p>
  </body>
</html></richcontent>
<node CREATED="1567483868738" ID="ID_1698382569" MODIFIED="1567483879882" TEXT="f(n) = n * (n + 1) / 2 = O(n^2)">
<node CREATED="1567483945779" ID="ID_176704251" MODIFIED="1567483957976" TEXT="n + n - 1 + n - 2 + ... + 2 + 1"/>
</node>
</node>
</node>
<node CREATED="1567483967627" ID="ID_199317909" MODIFIED="1567483992833" TEXT="Suppose we have a sorted array and we want to find the index of a particular value in the array, if it existss. What is the time complexity of the following algorithm?">
<node CREATED="1567483996872" ID="ID_350440965" MODIFIED="1567484076382">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      low := 0
    </p>
    <p>
      high := n - 1
    </p>
    <p>
      While low &lt;= high Do
    </p>
    <p>
      &#160;&#160;&#160;&#160;mid := (low + high) / 2
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;&#160;&#160;If array[mid] == value: return mid
    </p>
    <p>
      &#160;&#160;&#160;&#160;Else If array[mid] &lt; value: lo = mid + 1
    </p>
    <p>
      &#160;&#160;&#160;&#160;Else if array[mid] &gt; value: hi = mid - 1
    </p>
    <p>
      
    </p>
    <p>
      return -1 // Value not found
    </p>
  </body>
</html></richcontent>
<node CREATED="1567739365040" ID="ID_918302151" MODIFIED="1567739378222" TEXT="O(log_2(n)) = O(log(n))"/>
</node>
</node>
<node CREATED="1567739388910" ID="ID_802167150" MODIFIED="1567739440079">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      i := 0
    </p>
    <p>
      While i &lt; n Do
    </p>
    <p>
      &#160;&#160;&#160;&#160;j = 0
    </p>
    <p>
      &#160;&#160;&#160;&#160;While j &lt; 3 * n Do
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;j = j + 1
    </p>
    <p>
      &#160;&#160;&#160;&#160;j = 0
    </p>
    <p>
      &#160;&#160;&#160;&#160;While j &lt; 2 * n Do
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;j = j + 1
    </p>
    <p>
      &#160;&#160;&#160;&#160;i = i + 1
    </p>
  </body>
</html></richcontent>
<node CREATED="1567740156422" ID="ID_115184184" MODIFIED="1567740181698" TEXT="f(n) = n(3 * n + 2 * n)">
<node CREATED="1567740182676" ID="ID_1272501794" MODIFIED="1567740187971" TEXT="5n^2">
<node CREATED="1567740188723" ID="ID_1071984168" MODIFIED="1567740192243" TEXT="O(n^2)"/>
</node>
</node>
<node CREATED="1567740208040" ID="ID_505467184" MODIFIED="1567740218959" TEXT="Usually we multiply loops to understand the complexity"/>
</node>
<node CREATED="1567740386348" ID="ID_1644365420" MODIFIED="1567740447875">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      i := 0
    </p>
    <p>
      While i &lt; 3 * n Do
    </p>
    <p>
      &#160;&#160;&#160;&#160;j := 10
    </p>
    <p>
      &#160;&#160;&#160;&#160;While j &lt;= 50 Do
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;j = j + 1
    </p>
    <p>
      &#160;&#160;&#160;&#160;j = 0
    </p>
    <p>
      &#160;&#160;&#160;&#160;While j &lt; n * n * n Do
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;j = j + 2
    </p>
    <p>
      &#160;&#160;&#160;&#160;i = i + 1
    </p>
  </body>
</html></richcontent>
<node CREATED="1567740469664" ID="ID_1964911772" MODIFIED="1567740516504" TEXT="3n(40 + n^3 / 2)">
<node CREATED="1567740516967" ID="ID_1730363809" MODIFIED="1567740532763" TEXT="120n + 3/2 n^4">
<node CREATED="1567740533537" ID="ID_1552370744" MODIFIED="1567740536243" TEXT="O(n^4)"/>
</node>
</node>
</node>
</node>
<node CREATED="1567740663162" ID="ID_719426810" MODIFIED="1567740673401" TEXT="Classic algorithms">
<node CREATED="1567740677239" ID="ID_1505914170" MODIFIED="1567740684114" TEXT="Finding all subsets of a set">
<node CREATED="1567740684385" ID="ID_1747181382" MODIFIED="1567740697154" TEXT="O(2^n)"/>
</node>
<node CREATED="1567740700792" ID="ID_4910673" MODIFIED="1567740707281" TEXT="Finding all permutations of a string">
<node CREATED="1567740711999" ID="ID_1080694945" MODIFIED="1567740714790" TEXT="O(n!)"/>
</node>
<node CREATED="1567740715783" ID="ID_993495177" MODIFIED="1567740723287" TEXT="Sorting using mergesort">
<node CREATED="1567740723680" ID="ID_619216783" MODIFIED="1567740734601" TEXT="O(nlog(n))"/>
</node>
<node CREATED="1567740735671" ID="ID_274602272" MODIFIED="1567740748601" TEXT="Iterating over all the cells in a matrix of size n by m">
<node CREATED="1567740749100" ID="ID_1221718477" MODIFIED="1567740751369" TEXT="O(nm)"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047528993" ID="ID_1399730678" MODIFIED="1567047577626" POSITION="left" TEXT="Static and dynamic arrays">
<node CREATED="1567047581826" ID="ID_1451464606" MODIFIED="1567047587379" TEXT="Static and dynamic arrays">
<node CREATED="1567740969214" ID="ID_891909700" MODIFIED="1567740986912" TEXT="It is a fundamental building block for all other data structures">
<node CREATED="1567741001708" ID="ID_402506270" MODIFIED="1567741023847" TEXT="With arrays and pointers, we can pretty much construct most of the other data structures"/>
</node>
<node CREATED="1567742283054" ID="ID_1012995521" MODIFIED="1567742285829" TEXT="Outline">
<node CREATED="1567742288074" ID="ID_1682683025" MODIFIED="1567742294779" TEXT="Discussion and examples about Arrays">
<node CREATED="1567743038338" ID="ID_541205340" MODIFIED="1567743042218" TEXT="What is an Array?">
<node CREATED="1567743215862" ID="ID_60098891" MODIFIED="1567743220554" TEXT="What is a static Array?">
<node CREATED="1567743223564" ID="ID_282012604" MODIFIED="1567743325256" TEXT="it is a fixed length container containing n elementss indexable from the range [0, n-1]]">
<node CREATED="1567743347888" ID="ID_1033098623" MODIFIED="1567743355733" TEXT="What is meant by being &apos;indesable&apos;?">
<node CREATED="1567743363014" ID="ID_1508750640" MODIFIED="1567743378119" TEXT="Each slock/index in the array can be referenced with a number"/>
<node CREATED="1567743570768" ID="ID_128896455" MODIFIED="1567743583660" TEXT="static array&apos;s are contiguous">
<node CREATED="1567743584199" ID="ID_1696497962" MODIFIED="1567743590648" TEXT="all the addresses are adjacent"/>
</node>
<node CREATED="1567743595064" ID="ID_250048985" MODIFIED="1567743601907" TEXT="When and where is a static Array used?">
<node CREATED="1567743604729" ID="ID_265349520" MODIFIED="1567743613218" TEXT="Storing and accessing sequential data"/>
<node CREATED="1567743613784" ID="ID_958677039" MODIFIED="1567743619441" TEXT="Temporarily storing objects"/>
<node CREATED="1567743619653" ID="ID_1231884551" MODIFIED="1567743633732" TEXT="Used by IO routines as buffers">
<node CREATED="1567744097508" ID="ID_105571827" MODIFIED="1567744108098" TEXT="small chunks are read into buffer"/>
</node>
<node CREATED="1567743635300" ID="ID_189133681" MODIFIED="1567743641672" TEXT="Lookup tables and inverse lookup tables"/>
<node CREATED="1567743660827" ID="ID_513605889" MODIFIED="1567743670561" TEXT="Can be used to return multiple values from a function"/>
<node CREATED="1567743677389" ID="ID_1399756762" MODIFIED="1567743692751" TEXT="Used in dynamic programming to cache answers to subproblems">
<node CREATED="1567744163727" ID="ID_1297602780" MODIFIED="1567744166302" TEXT="knapsack"/>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567743042735" ID="ID_1889701925" MODIFIED="1567743051502" TEXT="When and where is Array used?"/>
<node CREATED="1567743052743" ID="ID_809712671" MODIFIED="1567743054761" TEXT="Complexity">
<node CREATED="1567744182855" ID="ID_334982288" MODIFIED="1567744196270" TEXT="Static array">
<node CREATED="1567744196708" ID="ID_262077195" MODIFIED="1567744199798" TEXT="Access">
<node CREATED="1567744216132" ID="ID_1972610693" MODIFIED="1567744217646" TEXT="O(1)"/>
</node>
<node CREATED="1567744220956" ID="ID_1165848702" MODIFIED="1567744222310" TEXT="Search">
<node CREATED="1567744224511" ID="ID_1921765869" MODIFIED="1567744226014" TEXT="O(n)"/>
</node>
<node CREATED="1567744238447" ID="ID_285228148" MODIFIED="1567744240567" TEXT="Insertion">
<node CREATED="1567744241636" ID="ID_570212304" MODIFIED="1567744245735" TEXT="N/A"/>
</node>
<node CREATED="1567744262110" ID="ID_296613237" MODIFIED="1567744263527" TEXT="Appending">
<node CREATED="1567744263856" ID="ID_1328649856" MODIFIED="1567744265256" TEXT="N/A"/>
</node>
<node CREATED="1567744274481" ID="ID_1178520383" MODIFIED="1567744276512" TEXT="Deletion">
<node CREATED="1567744276799" ID="ID_941271524" MODIFIED="1567744277856" TEXT="N/A"/>
</node>
</node>
<node CREATED="1567744203732" ID="ID_30653370" MODIFIED="1567744207142" TEXT="Dynamic array">
<node CREATED="1567744208007" ID="ID_241189416" MODIFIED="1567744211486" TEXT="Access">
<node CREATED="1567744212620" ID="ID_722521109" MODIFIED="1567744214158" TEXT="O(1)"/>
</node>
<node CREATED="1567744228483" ID="ID_922961325" MODIFIED="1567744230046" TEXT="Search">
<node CREATED="1567744230436" ID="ID_425857956" MODIFIED="1567744232463" TEXT="O(n)"/>
</node>
<node CREATED="1567744248504" ID="ID_1442482277" MODIFIED="1567744250055" TEXT="Insertion">
<node CREATED="1567744250493" ID="ID_979607167" MODIFIED="1567744251847" TEXT="O(n)">
<node CREATED="1567744366243" ID="ID_1928402019" MODIFIED="1567744378835" TEXT="Need to shift all the elements to the right (worst case)">
<node CREATED="1567744381028" ID="ID_425834286" MODIFIED="1567744386316" TEXT="Assumption">
<node CREATED="1567744386609" ID="ID_242421637" MODIFIED="1567744392979" TEXT="Implementing dynamic array using static array"/>
</node>
</node>
</node>
</node>
<node CREATED="1567744266717" ID="ID_1106006380" MODIFIED="1567744268047" TEXT="Appending">
<node CREATED="1567744268260" ID="ID_1847058056" MODIFIED="1567744270087" TEXT="O(1)">
<node CREATED="1567744494375" ID="ID_1849886656" MODIFIED="1567744509445" TEXT="Need to resize but amortized cost is constant"/>
</node>
</node>
<node CREATED="1567744279540" ID="ID_1659958774" MODIFIED="1567744283896" TEXT="Deletion">
<node CREATED="1567744284104" ID="ID_881689456" MODIFIED="1567744285448" TEXT="O(n)">
<node CREATED="1567744512157" ID="ID_936562656" MODIFIED="1567744522757" TEXT="Need to shift all the elements to the right"/>
</node>
</node>
</node>
</node>
<node CREATED="1567743057067" ID="ID_1990103355" MODIFIED="1567743061985" TEXT="Static array usage example">
<node CREATED="1567820192174" ID="ID_1542035116" MODIFIED="1567820244806">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Elements in A are referenced by their index.
    </p>
    <p>
      There is no other way to access elements in an array.
    </p>
    <p>
      Array indexing is zero-based, meaning the first element is found in position zero.
    </p>
  </body>
</html></richcontent>
<node CREATED="1567820338883" ID="ID_29717769" MODIFIED="1567820347986" TEXT="Quntum Computing">
<node CREATED="1567820350610" ID="ID_404335549" MODIFIED="1567820355290" TEXT="indexing doesn&apos;t work well"/>
</node>
</node>
</node>
</node>
<node CREATED="1567743071768" ID="ID_395567913" MODIFIED="1567743080002" TEXT="Dynamic Array implementation details">
<node CREATED="1567743202507" ID="ID_1847691529" MODIFIED="1567743207017" TEXT="Using only static array"/>
<node CREATED="1567820436944" ID="ID_145700277" MODIFIED="1567820442681" TEXT="Dynamic Array">
<node CREATED="1567820446312" ID="ID_1819139855" MODIFIED="1567820454849" TEXT="Can grow and shrink in size">
<node CREATED="1567820459307" ID="ID_159438728" MODIFIED="1567820463369" TEXT="A.add(-7)"/>
<node CREATED="1567820467756" ID="ID_396155446" MODIFIED="1567820472148" TEXT="A.add(34)"/>
<node CREATED="1567820472851" ID="ID_1838616854" MODIFIED="1567820476301" TEXT="A.remove(4)"/>
</node>
<node CREATED="1567820514481" ID="ID_1950396911" MODIFIED="1567820523691" TEXT="How can we implement a dynamic array?">
<node CREATED="1567820524076" ID="ID_444368617" MODIFIED="1567820532813" TEXT="One way is to use a static array">
<node CREATED="1567820537018" ID="ID_1642198053" MODIFIED="1567820546752" TEXT="Construct a static array with an initial capacity"/>
<node CREATED="1567820547165" ID="ID_1130028197" MODIFIED="1567820564437" TEXT="Add elements to the underlying static array, keeping track of the number of elements"/>
<node CREATED="1567820564661" ID="ID_1999783764" MODIFIED="1567820588396" TEXT="If adding another element will exceed the capacity, then construct a new static array with twice the capacity and copy the original elements into it">
<node CREATED="1567820950685" ID="ID_87292204" MODIFIED="1567820959165" TEXT="Implement dyamic array using generics">
<node CREATED="1567821143544" ID="ID_1340604753" MODIFIED="1567821147938" TEXT="Implement Iterator"/>
<node CREATED="1567821148470" ID="ID_1877391349" MODIFIED="1567821155291" TEXT="Implement toString()"/>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567743081898" ID="ID_1673304816" MODIFIED="1567743085196" TEXT="Code Implementation"/>
</node>
</node>
<node CREATED="1567047588529" ID="ID_1239959045" MODIFIED="1567047594145" TEXT="Dynamic array source code"/>
</node>
<node CREATED="1567047597595" ID="ID_1783641617" MODIFIED="1567047604763" POSITION="right" TEXT="Linked lists">
<node CREATED="1567047608399" ID="ID_1422994141" MODIFIED="1567047614545" TEXT="Linked list introduction">
<node CREATED="1567833120599" ID="ID_976775126" MODIFIED="1567833123249" TEXT="Outline">
<node CREATED="1567833123633" ID="ID_1729536421" MODIFIED="1567833135081" TEXT="Discussion about Singly &amp; Doubly Linked Lists">
<node CREATED="1567833135729" ID="ID_1366817558" MODIFIED="1567833141521" TEXT="What is a linked list?">
<node CREATED="1567833970993" ID="ID_1795758471" MODIFIED="1567833976747" TEXT="Singly and Doubly Linked Lists"/>
<node CREATED="1567834027206" ID="ID_1355595821" MODIFIED="1567834066737" TEXT="A liked list is a sequential list of nodes that hold data which point to other nodes also containing data.">
<node CREATED="1567834079284" ID="ID_462711654" MODIFIED="1567834091990" TEXT="Every node has a pointer to next node"/>
<node CREATED="1567834092698" ID="ID_1697236078" MODIFIED="1567834097692" TEXT="Last node has null reference"/>
</node>
</node>
<node CREATED="1567833141769" ID="ID_388690781" MODIFIED="1567833148230" TEXT="Where are linked lists used?">
<node CREATED="1567834459445" ID="ID_1329287514" MODIFIED="1567834469714" TEXT="Used in many List, Queue &amp; Stack implementations"/>
<node CREATED="1567834471745" ID="ID_1241012632" MODIFIED="1567834479224" TEXT="Great for constructing circular lists">
<node CREATED="1567834550017" ID="ID_359877582" MODIFIED="1567834558778" TEXT="pointer of last node is pointing to first node"/>
<node CREATED="1567834561649" ID="ID_225662096" MODIFIED="1567834569371" TEXT="Round robbin scheduling"/>
</node>
<node CREATED="1567834479472" ID="ID_623874626" MODIFIED="1567834489927" TEXT="Can easily model real world objects such as trains"/>
<node CREATED="1567834490160" ID="ID_145618758" MODIFIED="1567834512840" TEXT="Used in separate chaining, which is present certain Hashtable implementations to deal with hashing collisions"/>
<node CREATED="1567834514768" ID="ID_1618861595" MODIFIED="1567834525659" TEXT="Often used in the implementation of adjacency lists for graphs"/>
</node>
<node CREATED="1567833148455" ID="ID_967352583" MODIFIED="1567833151528" TEXT="Terminology">
<node CREATED="1567834599921" ID="ID_950423457" MODIFIED="1567834601524" TEXT="Head">
<node CREATED="1567834602621" ID="ID_1648984151" MODIFIED="1567834607076" TEXT="first node in a linked list">
<node CREATED="1567834607308" ID="ID_1279551557" MODIFIED="1567834612008" TEXT="always need to maintain this"/>
</node>
</node>
<node CREATED="1567853453437" ID="ID_1875776916" MODIFIED="1567853454487" TEXT="Tail">
<node CREATED="1567853454806" ID="ID_1814523700" MODIFIED="1567853462343" TEXT="last node in a linked list"/>
</node>
<node CREATED="1567853465088" ID="ID_781963862" MODIFIED="1567853468839" TEXT="Pointer">
<node CREATED="1567853469156" ID="ID_1538542627" MODIFIED="1567853476286" TEXT="reference to another node"/>
</node>
<node CREATED="1567853477239" ID="ID_156367923" MODIFIED="1567853478663" TEXT="Node">
<node CREATED="1567853479141" ID="ID_217982775" MODIFIED="1567853488493" TEXT="object containing data and pointer(s)"/>
</node>
</node>
<node CREATED="1567833151759" ID="ID_169836061" MODIFIED="1567833160377" TEXT="Singly Linked vs. Doubly Linked">
<node CREATED="1567864996558" ID="ID_1104303525" MODIFIED="1567865051806" TEXT="Singly linked lists only hold a reference to the next node. In the implementation you always maintain a reference to the head to the linked list and a reference to the tail node for quick additions/ removals."/>
<node CREATED="1567865055371" ID="ID_978648675" MODIFIED="1567865123988" TEXT="With a doubly linked list each node holds a reference to the next and previous node. In the implementation you always maintain a reference to the head and the tail of the doubly linked list to do quick additions/removals from both ends of your list."/>
<node CREATED="1567865310771" ID="ID_346037168" MODIFIED="1567865313974" TEXT="Pros">
<node CREATED="1567865320391" ID="ID_1667514471" MODIFIED="1567865352343" TEXT="Singly linked list">
<node CREATED="1567865326459" ID="ID_63764172" MODIFIED="1567865332350" TEXT="uses less(er) memory"/>
<node CREATED="1567865333976" ID="ID_777245891" MODIFIED="1567865340446" TEXT="simpler implementation"/>
</node>
<node CREATED="1567865341216" ID="ID_976989408" MODIFIED="1567865345847" TEXT="Doubly linked list">
<node CREATED="1567865362178" ID="ID_1080365259" MODIFIED="1567865366901" TEXT="can be traversed backwards"/>
<node CREATED="1567865472012" ID="ID_840852753" MODIFIED="1567865478986" TEXT="we can remove a node in constant time">
<node CREATED="1567865489762" ID="ID_181798720" MODIFIED="1567865509013" TEXT="needs reference to previous node">
<node CREATED="1567865515862" ID="ID_1457513154" MODIFIED="1567865517093" TEXT="easy"/>
</node>
</node>
</node>
</node>
<node CREATED="1567865314206" ID="ID_1876370493" MODIFIED="1567865317110" TEXT="Cons">
<node CREATED="1567865371197" ID="ID_975406318" MODIFIED="1567865383642" TEXT="cannot easily access previous elements"/>
<node CREATED="1567865384795" ID="ID_1992008723" MODIFIED="1567865390397" TEXT="takes 2x memory">
<node CREATED="1567865409828" ID="ID_1946301276" MODIFIED="1567865418307" TEXT="on a 64 bit machine">
<node CREATED="1567865418508" ID="ID_89154144" MODIFIED="1567865423980" TEXT="references take 8 bytes"/>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567833162559" ID="ID_1624272856" MODIFIED="1567833166761" TEXT="Implementation Details">
<node CREATED="1567833166984" ID="ID_277366498" MODIFIED="1567833171679" TEXT="How to insert new elements">
<node CREATED="1567866354284" ID="ID_1038091725" MODIFIED="1567866477772">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      trav &lt;- head
    </p>
    <p>
      trav &lt;- trav.next
    </p>
    <p>
      newNode.data &lt;- 11
    </p>
    <p>
      newNode.next &lt;- trav.next
    </p>
    <p>
      trav.next &lt;- newNode
    </p>
  </body>
</html></richcontent>
</node>
<node CREATED="1567866498968" ID="ID_11541807" MODIFIED="1567866503726" TEXT="doubly linked list">
<node CREATED="1567866505064" ID="ID_845284105" MODIFIED="1567866588130">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      trav &lt;- head
    </p>
    <p>
      trav &lt;- trav.next
    </p>
    <p>
      newNode.data &lt;- 11
    </p>
    <p>
      newNode.next &lt;- pos
    </p>
    <p>
      newNode.prev &lt;- trav
    </p>
    <p>
      pos.prev &lt;- newNode
    </p>
    <p>
      trav.nex &lt;- newNode
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node CREATED="1567833171882" ID="ID_1690375808" MODIFIED="1567833177159" TEXT="How to remove elements">
<node CREATED="1567866604842" ID="ID_553375484" MODIFIED="1567866609322" TEXT="singly linked list">
<node CREATED="1567866610465" ID="ID_875555249" MODIFIED="1567866624974" TEXT="using two pointers">
<node CREATED="1567866630230" ID="ID_1259552629" MODIFIED="1567866733700">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      trav1 &lt;- head
    </p>
    <p>
      trav2 &lt;- head.next
    </p>
    <p>
      trav2 &lt;- trav2.next
    </p>
    <p>
      trav1 &lt;- trav1.next
    </p>
    <p>
      ...
    </p>
    <p>
      temp &lt;- trav2
    </p>
    <p>
      trav2 &lt;- trav2.next
    </p>
    <p>
      trav1.next &lt;- trav2
    </p>
    <p>
      remove temp
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node CREATED="1567866736098" ID="ID_1514077046" MODIFIED="1567866739173" TEXT="doubly linked list">
<node CREATED="1567866779586" ID="ID_420048895" MODIFIED="1567866782770" TEXT="use single pointer">
<node CREATED="1567866783035" ID="ID_1844735609" MODIFIED="1567866851591">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      trav &lt;- head
    </p>
    <p>
      trav &lt;- trav.next
    </p>
    <p>
      trav.prev.next &lt;- trav.next
    </p>
    <p>
      trav.next.prev &lt;- trav.prev
    </p>
    <p>
      remove trav
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567833179097" ID="ID_186455063" MODIFIED="1567833184058" TEXT="Complexity analysis">
<node CREATED="1567866873482" ID="ID_1853046036" MODIFIED="1567866878531" TEXT="singly linked list">
<node CREATED="1567866882502" ID="ID_330483936" MODIFIED="1567866885811" TEXT="search">
<node CREATED="1567866885972" ID="ID_517357335" MODIFIED="1567866887548" TEXT="O(n)"/>
</node>
<node CREATED="1567866890835" ID="ID_415155634" MODIFIED="1567866894892" TEXT="insert at head">
<node CREATED="1567866895123" ID="ID_96923319" MODIFIED="1567866897404" TEXT="O(1)"/>
</node>
<node CREATED="1567866905109" ID="ID_942875541" MODIFIED="1567866908884" TEXT="insert at tail">
<node CREATED="1567866909225" ID="ID_1015240473" MODIFIED="1567866911148" TEXT="O(1)"/>
</node>
<node CREATED="1567866981105" ID="ID_1833748317" MODIFIED="1567866984052" TEXT="remove at head">
<node CREATED="1567866984475" ID="ID_322332530" MODIFIED="1567866985772" TEXT="O(1)"/>
</node>
<node CREATED="1567866986938" ID="ID_1908370664" MODIFIED="1567866989804" TEXT="remove at tail">
<node CREATED="1567866993125" ID="ID_605897530" MODIFIED="1567866994484" TEXT="O(n)">
<node CREATED="1567867059287" ID="ID_958713840" MODIFIED="1567867069671" TEXT="tail needs to be reset"/>
</node>
</node>
<node CREATED="1567867001596" ID="ID_1081718839" MODIFIED="1567867004599" TEXT="remove in middle">
<node CREATED="1567867005238" ID="ID_1144151002" MODIFIED="1567867006399" TEXT="O(n)"/>
</node>
</node>
<node CREATED="1567866878954" ID="ID_1277221017" MODIFIED="1567866881762" TEXT="doubly linked list">
<node CREATED="1567866915970" ID="ID_1608402570" MODIFIED="1567866917525" TEXT="search">
<node CREATED="1567866917838" ID="ID_1086368704" MODIFIED="1567866922101" TEXT="O(n)"/>
</node>
<node CREATED="1567866924268" ID="ID_996696552" MODIFIED="1567866926573" TEXT="insert at head">
<node CREATED="1567866926761" ID="ID_853601712" MODIFIED="1567866928301" TEXT="O(1)"/>
</node>
<node CREATED="1567866929241" ID="ID_760740272" MODIFIED="1567866931893" TEXT="insert at tail">
<node CREATED="1567866932102" ID="ID_259382152" MODIFIED="1567866933533" TEXT="O(1)"/>
</node>
<node CREATED="1567867009975" ID="ID_427065675" MODIFIED="1567867011991" TEXT="remove at head">
<node CREATED="1567867012232" ID="ID_1280011565" MODIFIED="1567867013839" TEXT="O(1)"/>
</node>
<node CREATED="1567867014699" ID="ID_287686875" MODIFIED="1567867017286" TEXT="remove at tail">
<node CREATED="1567867017558" ID="ID_1089434193" MODIFIED="1567867018950" TEXT="O(1)"/>
</node>
<node CREATED="1567867019712" ID="ID_1874375030" MODIFIED="1567867022463" TEXT="remove in middle">
<node CREATED="1567867022757" ID="ID_1847715946" MODIFIED="1567867024263" TEXT="O(n)"/>
</node>
</node>
</node>
<node CREATED="1567833185111" ID="ID_833463333" MODIFIED="1567833189354" TEXT="Code Implementation">
<node CREATED="1567833189622" ID="ID_1257981521" MODIFIED="1567833193218" TEXT="Double Linked List">
<node CREATED="1567867203141" ID="ID_514488670" MODIFIED="1567867216631" TEXT="implement Iterable"/>
<node CREATED="1567867216889" ID="ID_555973994" MODIFIED="1567867220082" TEXT="Use generics"/>
<node CREATED="1567867226670" ID="ID_614584917" MODIFIED="1567867233610" TEXT="Define Node class"/>
<node CREATED="1567867246974" ID="ID_1126895755" MODIFIED="1567867254493" TEXT="operations">
<node CREATED="1567867257030" ID="ID_1706268935" MODIFIED="1567867258925" TEXT="toString"/>
<node CREATED="1567867259174" ID="ID_1362674625" MODIFIED="1567867261909" TEXT="clear"/>
<node CREATED="1567867264206" ID="ID_900226026" MODIFIED="1567867264871" TEXT="size"/>
<node CREATED="1567867266567" ID="ID_977142376" MODIFIED="1567867268485" TEXT="isEmpty"/>
<node CREATED="1567867291319" ID="ID_295176672" MODIFIED="1567867292288" TEXT="add"/>
<node CREATED="1567867293415" ID="ID_1042489593" MODIFIED="1567867294971" TEXT="addFirst"/>
<node CREATED="1567867303058" ID="ID_1587794680" MODIFIED="1567867305012" TEXT="addLast"/>
<node CREATED="1567867379119" ID="ID_815004841" MODIFIED="1567867382205" TEXT="peekFirst">
<node CREATED="1567867394796" ID="ID_1378199614" MODIFIED="1567867399213" TEXT="throw RuntimeException"/>
</node>
<node CREATED="1567867383812" ID="ID_835721909" MODIFIED="1567867385869" TEXT="peekLast"/>
<node CREATED="1567867387670" ID="ID_147300986" MODIFIED="1567867393420" TEXT="removeFirst"/>
<node CREATED="1567867463139" ID="ID_918055018" MODIFIED="1567867464347" TEXT="remove">
<node CREATED="1567867525303" ID="ID_853949203" MODIFIED="1567867528961" TEXT="return data"/>
</node>
<node CREATED="1567867531254" ID="ID_1335903396" MODIFIED="1567867532921" TEXT="removeAt">
<node CREATED="1567867534712" ID="ID_93504921" MODIFIED="1567867535641" TEXT="index">
<node CREATED="1567867573590" ID="ID_655246484" MODIFIED="1567867582157" TEXT="if closer to front, traverse from front"/>
</node>
</node>
<node CREATED="1567867584412" ID="ID_551074386" MODIFIED="1567867586708" TEXT="remove">
<node CREATED="1567867586946" ID="ID_817453311" MODIFIED="1567867588269" TEXT="object"/>
</node>
<node CREATED="1567867629858" ID="ID_1173421391" MODIFIED="1567867632305" TEXT="indexOf">
<node CREATED="1567867633830" ID="ID_1467810903" MODIFIED="1567867634902" TEXT="object">
<node CREATED="1567867650344" ID="ID_1124720010" MODIFIED="1567867658490" TEXT="if object is null, return the index"/>
</node>
</node>
<node CREATED="1567867662025" ID="ID_1552933879" MODIFIED="1567867663489" TEXT="contains">
<node CREATED="1567867669837" ID="ID_953521111" MODIFIED="1567867672436" TEXT="use indexOf"/>
</node>
<node CREATED="1567867676693" ID="ID_232629674" MODIFIED="1567867681779" TEXT="iterator">
<node CREATED="1567867702797" ID="ID_231782192" MODIFIED="1567867709748" TEXT="concurrent modification can be checked"/>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047616342" ID="ID_26747835" MODIFIED="1567047622360" TEXT="Doubly linked list source code"/>
</node>
<node CREATED="1567047624020" ID="ID_1851544901" MODIFIED="1567047628840" POSITION="left" TEXT="Stacks">
<node CREATED="1567047630177" ID="ID_354936170" MODIFIED="1567047633887" TEXT="Understanding stacks">
<node CREATED="1567867779650" ID="ID_1632968457" MODIFIED="1567867780985" TEXT="Outline">
<node CREATED="1567867784542" ID="ID_51889379" MODIFIED="1567867790522" TEXT="Discussion about Stacks">
<node CREATED="1567867791446" ID="ID_983885774" MODIFIED="1567867795089" TEXT="What is a Stack?">
<node CREATED="1567868294662" ID="ID_1890646272" MODIFIED="1567868320063" TEXT="A stack is a one-ended linear data structure which models a real world stack by having two primary operations, namely push and pop">
<node CREATED="1567868343781" ID="ID_546308158" MODIFIED="1567868345578" TEXT="top">
<node CREATED="1567868345815" ID="ID_153481245" MODIFIED="1567868347059" TEXT="pointer"/>
</node>
<node CREATED="1567868352394" ID="ID_1927693508" MODIFIED="1567868354370" TEXT="LIFO"/>
</node>
<node CREATED="1567868369852" ID="ID_1274139999" MODIFIED="1567868371207" TEXT="example">
<node CREATED="1567868371463" ID="ID_1887709427" MODIFIED="1567868374542" TEXT="instructions">
<node CREATED="1567868375087" ID="ID_561895132" MODIFIED="1567868422788">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      pop()
    </p>
    <p>
      push('Onion')
    </p>
    <p>
      push('Celery')
    </p>
    <p>
      push('Watermelon')
    </p>
    <p>
      pop()
    </p>
    <p>
      pop()
    </p>
    <p>
      push('Lettuce')
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
</node>
<node CREATED="1567867795355" ID="ID_403562840" MODIFIED="1567867803544" TEXT="When and where is a Stack used?">
<node CREATED="1567868441473" ID="ID_1893010171" MODIFIED="1567868453889" TEXT="Used by undo mechanism in text editors"/>
<node CREATED="1567868455818" ID="ID_773428452" MODIFIED="1567868470763" TEXT="Used in compiler syntax checking for matching brackets and braces"/>
<node CREATED="1567868471923" ID="ID_916567027" MODIFIED="1567868480875" TEXT="Can be used to model a pile of books or plates"/>
<node CREATED="1567868481086" ID="ID_1127383903" MODIFIED="1567868498941" TEXT="Used behind the scenes to support recursion by keeping track of previous function calls"/>
<node CREATED="1567868499348" ID="ID_464979143" MODIFIED="1567868511507" TEXT="Can be used to do a Depth First Search (DFS) on a graph"/>
<node CREATED="1567868545707" ID="ID_700327659" MODIFIED="1567868546901" TEXT="games">
<node CREATED="1567868547158" ID="ID_934977752" MODIFIED="1567868549685" TEXT="tower of hannoi"/>
</node>
</node>
<node CREATED="1567867803733" ID="ID_682283518" MODIFIED="1567867810106" TEXT="Complexity Analysis">
<node CREATED="1567868587005" ID="ID_35146974" MODIFIED="1567868589982" TEXT="push">
<node CREATED="1567868591095" ID="ID_1175170519" MODIFIED="1567868592327" TEXT="O(1)"/>
</node>
<node CREATED="1567868593173" ID="ID_447474788" MODIFIED="1567868594623" TEXT="pop()">
<node CREATED="1567868594851" ID="ID_1930600313" MODIFIED="1567868596463" TEXT="O(1)"/>
</node>
<node CREATED="1567868597291" ID="ID_1271883920" MODIFIED="1567868599431" TEXT="peek()">
<node CREATED="1567868599695" ID="ID_783731951" MODIFIED="1567868601871" TEXT="O(1)"/>
</node>
<node CREATED="1567868603240" ID="ID_503190249" MODIFIED="1567868605671" TEXT="search()">
<node CREATED="1567868606848" ID="ID_1369803216" MODIFIED="1567868608927" TEXT="O(n)">
<node CREATED="1567868651442" ID="ID_1503672373" MODIFIED="1567868656841" TEXT="need to scan from the top"/>
</node>
</node>
<node CREATED="1567868610128" ID="ID_1887850831" MODIFIED="1567868612255" TEXT="size()">
<node CREATED="1567868614161" ID="ID_328879783" MODIFIED="1567868618944" TEXT="O(1)"/>
</node>
</node>
<node CREATED="1567867810514" ID="ID_1220707808" MODIFIED="1567867815706" TEXT="Stack usage examples">
<node CREATED="1567868661843" ID="ID_1495474462" MODIFIED="1567868669181" TEXT="problem">
<node CREATED="1567868669362" ID="ID_227988786" MODIFIED="1567868697704" TEXT="Given a string made up of the following brackets: ()[]{}, determine whether the brackets properly match">
<node CREATED="1567868720738" ID="ID_382126135" MODIFIED="1567868739949" TEXT="Current Bracket, Reversed Bracket">
<node CREATED="1567868741941" ID="ID_1706006058" MODIFIED="1567868744956" TEXT="Track them"/>
</node>
<node CREATED="1567868919754" ID="ID_632329927" MODIFIED="1567868923524" TEXT="pseudocode">
<node CREATED="1567868924190" ID="ID_1475681509" MODIFIED="1567868999805">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Let S be a stack
    </p>
    <p>
      For bracket in bracket_string:
    </p>
    <p>
      &#160;&#160;&#160;&#160;rev = getReversedBracket(bracket)
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;&#160;&#160;If isLeftBracket(bracket):
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;S.push(bracket)
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;&#160;&#160;Else If S.isEmpty() or S.pop() != rev:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false // Invalid
    </p>
    <p>
      
    </p>
    <p>
      return S.isEmpty() // Valid if S is empty
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
</node>
<node CREATED="1567869088715" ID="ID_1503374573" MODIFIED="1567869093679" TEXT="tower of hanoi">
<node CREATED="1567869162784" ID="ID_755206345" MODIFIED="1567869176614" TEXT="can be implemented using push() and pop() operations"/>
</node>
</node>
</node>
<node CREATED="1567867819291" ID="ID_1184774594" MODIFIED="1567867823650" TEXT="Implementation details">
<node CREATED="1567867823891" ID="ID_1934476443" MODIFIED="1567867829649" TEXT="Pushing elements on stack"/>
<node CREATED="1567867829993" ID="ID_1410298915" MODIFIED="1567867836156" TEXT="Popping elements from stack"/>
</node>
<node CREATED="1567867837785" ID="ID_6120644" MODIFIED="1567867843139" TEXT="Code Implementation">
<node CREATED="1567869235477" ID="ID_678381324" MODIFIED="1567869238696" TEXT="singly linked list">
<node CREATED="1567869245706" ID="ID_1447832879" MODIFIED="1567869250635" TEXT="Head &lt;- null"/>
<node CREATED="1567869261115" ID="ID_1372982234" MODIFIED="1567869265976" TEXT="push()">
<node CREATED="1567869266325" ID="ID_70783602" MODIFIED="1567869275405" TEXT="insert before the head()"/>
</node>
<node CREATED="1567869307691" ID="ID_1286155703" MODIFIED="1567869310250" TEXT="pop()">
<node CREATED="1567873757452" ID="ID_904660103" MODIFIED="1567873759715" TEXT="Java">
<node CREATED="1567873759984" ID="ID_282262814" MODIFIED="1567873766050" TEXT="assign to null"/>
</node>
<node CREATED="1567873770760" ID="ID_257148189" MODIFIED="1567873772570" TEXT="C/C++">
<node CREATED="1567873772809" ID="ID_946344979" MODIFIED="1567873779026" TEXT="free/delete"/>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567868280836" ID="ID_216925841" MODIFIED="1567868282942" TEXT="Discussion"/>
</node>
<node CREATED="1567047634990" ID="ID_1954637024" MODIFIED="1567047640557" TEXT="Stack implementation details"/>
<node CREATED="1567047642263" ID="ID_1870968557" MODIFIED="1567047645764" TEXT="Stack source code">
<node CREATED="1567874546458" ID="ID_1087737339" MODIFIED="1567874548840" TEXT="operations">
<node CREATED="1567874549066" ID="ID_814970242" MODIFIED="1567874552722" TEXT="isEmpty"/>
<node CREATED="1567874553785" ID="ID_1705551405" MODIFIED="1567874554776" TEXT="push"/>
<node CREATED="1567874555010" ID="ID_128960302" MODIFIED="1567874556275" TEXT="pop"/>
<node CREATED="1567874556752" ID="ID_463079582" MODIFIED="1567874557784" TEXT="peek"/>
<node CREATED="1567874587478" ID="ID_683268280" MODIFIED="1567874590074" TEXT="iterator"/>
</node>
</node>
</node>
<node CREATED="1567047647640" ID="ID_758481653" MODIFIED="1567047652152" POSITION="right" TEXT="Queues">
<node CREATED="1567047654280" ID="ID_686273722" MODIFIED="1567047658504" TEXT="Understanding queues">
<node CREATED="1567875181348" ID="ID_240456656" MODIFIED="1567875182964" TEXT="Outline">
<node CREATED="1567875183170" ID="ID_274061719" MODIFIED="1567875188522" TEXT="Discussion About Queues">
<node CREATED="1567875189932" ID="ID_207525459" MODIFIED="1567875193475" TEXT="What is a queue?">
<node CREATED="1567875340296" ID="ID_1930591323" MODIFIED="1567875367369" TEXT="A queue is a linear data structure which models real world queues by having two primary operations, namely enqueue and dequeue"/>
</node>
<node CREATED="1567875193689" ID="ID_1313118671" MODIFIED="1567875196908" TEXT="Terminology">
<node CREATED="1567875393844" ID="ID_375265685" MODIFIED="1567875397332" TEXT="Queue Front">
<node CREATED="1567875401045" ID="ID_1460939009" MODIFIED="1567875405356" TEXT="Used to dequeue"/>
</node>
<node CREATED="1567875397545" ID="ID_764050732" MODIFIED="1567875399836" TEXT="Queue Back">
<node CREATED="1567875406224" ID="ID_1783712288" MODIFIED="1567875412100" TEXT="Used to enqueue"/>
</node>
<node CREATED="1567875430132" ID="ID_1226262060" MODIFIED="1567875454055" TEXT="There does not seem to be a consistent terminology for inserting and removing elements from queues">
<node CREATED="1567875455522" ID="ID_1196420610" MODIFIED="1567875461483" TEXT="Enqueue = Adding = Offering"/>
<node CREATED="1567875956848" ID="ID_1689657762" MODIFIED="1567875961066" TEXT="Dequeue = Polling">
<node CREATED="1567875969080" ID="ID_1392341799" MODIFIED="1567875974658" TEXT="removing (another term)"/>
</node>
</node>
<node CREATED="1567876017738" ID="ID_1108660989" MODIFIED="1567876019260" TEXT="Example"/>
</node>
<node CREATED="1567875197120" ID="ID_25662673" MODIFIED="1567875246762" TEXT="When and where is queue used?">
<node CREATED="1567876061482" ID="ID_1788099241" MODIFIED="1567876080657" TEXT="Any waiting line models a queue, for example a lineup at a movie theatre"/>
<node CREATED="1567876081154" ID="ID_1424754155" MODIFIED="1567876099124" TEXT="Can be used to efficiently keep track of the most recently added elements">
<node CREATED="1567912649645" ID="ID_1656308401" MODIFIED="1567912654327" TEXT="x most recent elements"/>
</node>
<node CREATED="1567876100287" ID="ID_422620552" MODIFIED="1567876114112" TEXT="Web server request management where you want first come first serve">
<node CREATED="1567912658327" ID="ID_928945960" MODIFIED="1567912660990" TEXT="web server">
<node CREATED="1567912661203" ID="ID_1729824058" MODIFIED="1567924990763" TEXT="limit number of requests"/>
</node>
</node>
<node CREATED="1567876115307" ID="ID_66233979" MODIFIED="1567876125475" TEXT="Breadth first search (BFS) graph traversal"/>
</node>
<node CREATED="1567875246983" ID="ID_589812612" MODIFIED="1567875252714" TEXT="Complexity Analysis">
<node CREATED="1567925034847" ID="ID_1458160180" MODIFIED="1567925039431" TEXT="Enqueue">
<node CREATED="1567925039901" ID="ID_1747013365" MODIFIED="1567925041271" TEXT="O(1)"/>
</node>
<node CREATED="1567925042983" ID="ID_149013510" MODIFIED="1567925044751" TEXT="Dequeue">
<node CREATED="1567925045064" ID="ID_339379555" MODIFIED="1567925046968" TEXT="O(1)"/>
</node>
<node CREATED="1567925047814" ID="ID_785683913" MODIFIED="1567925050073" TEXT="Peek">
<node CREATED="1567925050339" ID="ID_1734584947" MODIFIED="1567925052016" TEXT="O(1)"/>
</node>
<node CREATED="1567925053542" ID="ID_1144454918" MODIFIED="1567925055511" TEXT="Contains">
<node CREATED="1567925055974" ID="ID_1711752867" MODIFIED="1567925057295" TEXT="O(n)"/>
</node>
<node CREATED="1567925058380" ID="ID_146970559" MODIFIED="1567925059879" TEXT="Removal">
<node CREATED="1567925063256" ID="ID_391550369" MODIFIED="1567925064487" TEXT="O(n)"/>
</node>
<node CREATED="1567925065653" ID="ID_955457785" MODIFIED="1567925068296" TEXT="Is Empty">
<node CREATED="1567925070237" ID="ID_1283036862" MODIFIED="1567925071471" TEXT="O(1)"/>
</node>
</node>
<node CREATED="1567875252931" ID="ID_267068591" MODIFIED="1567875264352" TEXT="Queue Breadth First Search (BFS) example">
<node CREATED="1567925210352" ID="ID_1178615574" MODIFIED="1567925219568" TEXT="Graph">
<node CREATED="1567925219798" ID="ID_1263901226" MODIFIED="1567925221282" TEXT="network"/>
</node>
<node CREATED="1567925231946" ID="ID_1063213379" MODIFIED="1567925239780" TEXT="Visit all neighbors first">
<node CREATED="1567925339593" ID="ID_1663016612" MODIFIED="1567925344753" TEXT="pseudocode">
<node CREATED="1567925345014" ID="ID_407391168" MODIFIED="1567925425956">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Let Q be a Queue
    </p>
    <p>
      Q.enqueue(starting_node)
    </p>
    <p>
      starting_node.visited = true
    </p>
    <p>
      
    </p>
    <p>
      While Q is not empty Do
    </p>
    <p>
      &#160;&#160;&#160;&#160;node = Q.dequeue()
    </p>
    <p>
      &#160;
    </p>
    <p>
      &#160;&#160;&#160;&#160;For neighbour in neighbours(node):
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;If neighbour has not be visited:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;neighbour.visited = true
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Q.enqueue(neighbour)
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567875269668" ID="ID_1551527789" MODIFIED="1567875275682" TEXT="Implementation Details">
<node CREATED="1567875276027" ID="ID_494219592" MODIFIED="1567875285634" TEXT="How to enqueue (add) elements to a queue"/>
<node CREATED="1567875286119" ID="ID_1284956826" MODIFIED="1567875296171" TEXT="How to dequeue (remove) elements from a queue"/>
</node>
<node CREATED="1567875297444" ID="ID_1558954493" MODIFIED="1567875301851" TEXT="Code Implementation">
<node CREATED="1567925582370" ID="ID_534483534" MODIFIED="1567925585746" TEXT="Singly linked list">
<node CREATED="1567925590691" ID="ID_1167338103" MODIFIED="1567925610068" TEXT="As we enqueue, push tail pointer forward"/>
<node CREATED="1567925623381" ID="ID_915551759" MODIFIED="1567925635482" TEXT="As we dequeue, push the head pointer forward"/>
</node>
<node CREATED="1567927203841" ID="ID_1130257495" MODIFIED="1567927210275" TEXT="Implement Iterable"/>
<node CREATED="1567927369673" ID="ID_1764699491" MODIFIED="1567927373071" TEXT="isEmpty"/>
<node CREATED="1567927374127" ID="ID_1608192963" MODIFIED="1567927375454" TEXT="size"/>
<node CREATED="1567927376255" ID="ID_1617711611" MODIFIED="1567927437923" TEXT="static array based queue">
<node CREATED="1567927438125" ID="ID_52190493" MODIFIED="1567927440936" TEXT="home work"/>
</node>
</node>
</node>
<node CREATED="1567875322692" ID="ID_603148716" MODIFIED="1567875326351" TEXT="Discussion"/>
</node>
<node CREATED="1567047660377" ID="ID_681540935" MODIFIED="1567047668411" TEXT="Breadth first search and queue implementation"/>
<node CREATED="1567047670440" ID="ID_1992317809" MODIFIED="1567047673945" TEXT="Queue source code"/>
</node>
<node CREATED="1567047679733" ID="ID_621356158" MODIFIED="1567047688824" POSITION="left" TEXT="Priority queues">
<node CREATED="1567047692065" ID="ID_356779383" MODIFIED="1567047697048" TEXT="What is a priority queue?">
<node CREATED="1567927484233" ID="ID_1738146176" MODIFIED="1567927486616" TEXT="Outline">
<node CREATED="1567927489529" ID="ID_243588299" MODIFIED="1567927498557" TEXT="Discussion &amp; Examples of PQs">
<node CREATED="1567927501449" ID="ID_1149790374" MODIFIED="1567927505551" TEXT="What is a PQ?">
<node CREATED="1567927708254" ID="ID_866861179" MODIFIED="1567927771728" TEXT="A priority queue is an Abstract Data Type (ADT) that operates similar to a normal queue except that each element has a certain priority. The priority of the elements in the priority queue determine the order in which elements are removed from the PQ"/>
<node CREATED="1567927798155" ID="ID_254216768" MODIFIED="1567927850030" TEXT="Note: Priority queues only supports comparable data, meaning the data inserted into the priority queue must be able to be ordered in some way either from least to greatest or greatest to least. This is so that we are able to assign relative priorities to each element. ">
<node CREATED="1567928080144" ID="ID_1774200146" MODIFIED="1567928082027" TEXT="Example">
<node CREATED="1567928085715" ID="ID_168261323" MODIFIED="1567928087345" TEXT="order">
<node CREATED="1567928087601" ID="ID_827309055" MODIFIED="1567928091954" TEXT="least to greatest number">
<node CREATED="1567928115426" ID="ID_1106455735" MODIFIED="1567928119322" TEXT="poll()">
<node CREATED="1567928119961" ID="ID_238234236" MODIFIED="1567928130838" TEXT="remove the element that has the highest priority"/>
</node>
<node CREATED="1567928233920" ID="ID_336213176" MODIFIED="1567928239934" TEXT="uses heap for implementation"/>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567927505784" ID="ID_1739084500" MODIFIED="1567927509576" TEXT="What is a heap?">
<node CREATED="1567928243382" ID="ID_1587978489" MODIFIED="1567928289943" TEXT="A heap is a tree based DS that satisfies the heap invariant (also called heap property): If A is a parent node of B then A is ordered with respect to B for all nodes A, B in the heap">
<node CREATED="1567928349904" ID="ID_746824915" MODIFIED="1567928351770" TEXT="Max heap">
<node CREATED="1567928353662" ID="ID_1226347480" MODIFIED="1567928356065" TEXT="A &gt;= B"/>
</node>
<node CREATED="1567928356930" ID="ID_1629362705" MODIFIED="1567928358443" TEXT="Min heap">
<node CREATED="1567928358747" ID="ID_135923404" MODIFIED="1567928360561" TEXT="A &lt;= B"/>
</node>
</node>
<node CREATED="1567928402619" ID="ID_1463459892" MODIFIED="1567928404805" TEXT="Why heaps?">
<node CREATED="1567928404997" ID="ID_166657406" MODIFIED="1567928411221" TEXT="Canonical data structure"/>
</node>
</node>
<node CREATED="1567927509814" ID="ID_1204252414" MODIFIED="1567927519024" TEXT="When and where is a PQ used?">
<node CREATED="1567928579618" ID="ID_806726178" MODIFIED="1567928596183" TEXT="Used in certain implementations of Dijkstra&apos;s Shortest Path algorithms"/>
<node CREATED="1567928597550" ID="ID_1360968967" MODIFIED="1567928619842" TEXT="Anytime you need the dynamically fetch the &apos;next best&apos; or &apos;next worst&apos; element"/>
<node CREATED="1567928624119" ID="ID_422539195" MODIFIED="1567928641283" TEXT="Used in Huffman coding (which is often used for lossless data compression)."/>
<node CREATED="1567928642637" ID="ID_1036216665" MODIFIED="1567928677700" TEXT="Best First Search (BFS) algorithms such as A* use PQs to continuously grab the next most promising node.">
<node CREATED="1567928735137" ID="ID_213306786" MODIFIED="1567928736963" TEXT="Graphs"/>
</node>
<node CREATED="1567928679645" ID="ID_1840973684" MODIFIED="1567928688353" TEXT="Used by Minimum Spanning Tree (MST) algorithms">
<node CREATED="1567928740117" ID="ID_1013726165" MODIFIED="1567928742011" TEXT="Digraphs"/>
</node>
<node CREATED="1567928746880" ID="ID_850920072" MODIFIED="1567928751815" TEXT="Usually Graph Theory algorithms"/>
</node>
<node CREATED="1567927519282" ID="ID_1788891877" MODIFIED="1567927530648" TEXT="How to turn a Min PQ into a Max PQ">
<node CREATED="1567928984587" ID="ID_1181084894" MODIFIED="1567928986308" TEXT="Problem">
<node CREATED="1567928986604" ID="ID_1465917842" MODIFIED="1567929030549" TEXT="Often the standard library of most programming languages only provide a min PQ which sorts by smallest elements first, but sometimes we need a Max PQ"/>
<node CREATED="1567929083577" ID="ID_651444612" MODIFIED="1567929110903" TEXT="Since elements in a priority queue are comparable they implement some sort of comparable interface which we can simply negate to achieve a Max heap">
<node CREATED="1567949186921" ID="ID_949613378" MODIFIED="1567949201784" TEXT="To convert, negate or convert the output of comparable interface">
<node CREATED="1567949210449" ID="ID_2998541" MODIFIED="1567949213664" TEXT="example">
<node CREATED="1567949213922" ID="ID_1979869853" MODIFIED="1567949247431" TEXT="Let x, y be numbers in the PQ. For a min PQ, if x &lt;= y then x comes out of the PQ before y, so the negation of this is if x &gt;= y then y comes out before x"/>
<node CREATED="1567949289426" ID="ID_243624665" MODIFIED="1567949317886" TEXT="An alternative method for numbers is to negate the numbers as you insert them into the PQ and negate them again when they are taken out. This has the same effect as negating the comparator">
<node CREATED="1567949319275" ID="ID_1661148376" MODIFIED="1567949322067" TEXT="works for numbers"/>
</node>
</node>
</node>
<node CREATED="1567949350482" ID="ID_748272057" MODIFIED="1567949357547" TEXT="Strings">
<node CREATED="1567949357764" ID="ID_217903430" MODIFIED="1567949423115" TEXT="Suppose lex is a comparator for strings which sorts strings in exicographic order (the default in most programming languages). Then let nlex be the negation of lex, and also let s1, s2 be strings">
<node CREATED="1567949429811" ID="ID_1703801504" MODIFIED="1567949443804" TEXT="lex(s1, s2) = -1 if s1 &lt; s2 lexicographically"/>
<node CREATED="1567949445172" ID="ID_1414813457" MODIFIED="1567949459355" TEXT="lex(s1, s2) = 0 if s1 = s2 lexicographically"/>
<node CREATED="1567949459755" ID="ID_388778203" MODIFIED="1567949472808" TEXT="lex(s1, s2) = +1 if s1 &gt; s2 lexicographically"/>
<node CREATED="1567949474007" ID="ID_874685129" MODIFIED="1567949491783" TEXT="nlex(s1, s2) = -(-1) = +1 s1 &lt; s2 lexicographically"/>
<node CREATED="1567949492154" ID="ID_323950069" MODIFIED="1567949509337" TEXT="nlex(s1, s2) = -(0) = 0 s1 = s2 lexicographically"/>
<node CREATED="1567949509590" ID="ID_270727751" MODIFIED="1567949524954" TEXT="nlex(s1, s2) = -(+1) = -1 s1 &gt; s2 lexicographically"/>
</node>
<node CREATED="1567949549295" ID="ID_625304416" MODIFIED="1567949551746" TEXT="example">
<node CREATED="1567949552552" ID="ID_386663184" MODIFIED="1567949570115" TEXT="By adding all these strings on the sright to the PQ with the lex comparator, we obtain the following:"/>
<node CREATED="1567949574737" ID="ID_70144343" MODIFIED="1567949575885" TEXT="nlex">
<node CREATED="1567949576793" ID="ID_1426988527" MODIFIED="1567949579685" TEXT="reverses the order"/>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567927531631" ID="ID_1046941321" MODIFIED="1567927536514" TEXT="Complexity Analysis">
<node CREATED="1567928757354" ID="ID_1231367622" MODIFIED="1567928764200" TEXT="Binary Heap construction">
<node CREATED="1567928764888" ID="ID_481229147" MODIFIED="1567928766180" TEXT="O(n)">
<node CREATED="1567928771828" ID="ID_785313119" MODIFIED="1567928777724" TEXT="Heap sorting algorithm"/>
</node>
</node>
<node CREATED="1567928779161" ID="ID_33050165" MODIFIED="1567928780597" TEXT="Polling">
<node CREATED="1567928780834" ID="ID_361001967" MODIFIED="1567928783756" TEXT="O(log(n))"/>
</node>
<node CREATED="1567928788973" ID="ID_1258056983" MODIFIED="1567928790605" TEXT="Peeking">
<node CREATED="1567928790828" ID="ID_1693170222" MODIFIED="1567928792471" TEXT="O(1)"/>
</node>
<node CREATED="1567928794570" ID="ID_1551900460" MODIFIED="1567928795676" TEXT="Adding">
<node CREATED="1567928796612" ID="ID_342051199" MODIFIED="1567928802974" TEXT="O(log(n))">
<node CREATED="1567928806041" ID="ID_985922242" MODIFIED="1567928811707" TEXT="Bubbling up value to re-order"/>
</node>
</node>
<node CREATED="1567928814629" ID="ID_1951105889" MODIFIED="1567928825157" TEXT="Naive Removing">
<node CREATED="1567928825341" ID="ID_1975499527" MODIFIED="1567928827541" TEXT="O(n)"/>
</node>
<node CREATED="1567928835182" ID="ID_1040666342" MODIFIED="1567928847415" TEXT="Advanced removing with help from a hash table">
<node CREATED="1567928847760" ID="ID_1397203816" MODIFIED="1567928851422" TEXT="O(log(n))">
<node CREATED="1567928925815" ID="ID_362130085" MODIFIED="1567928928826" TEXT="extra space"/>
</node>
</node>
<node CREATED="1567928853458" ID="ID_46590163" MODIFIED="1567928856671" TEXT="Naive contains">
<node CREATED="1567928857143" ID="ID_979621951" MODIFIED="1567928861822" TEXT="O(n)"/>
</node>
<node CREATED="1567928862744" ID="ID_562451747" MODIFIED="1567928870448" TEXT="Contains check with help of a hash table">
<node CREATED="1567928870622" ID="ID_137839379" MODIFIED="1567928873487" TEXT="O(1)"/>
</node>
</node>
</node>
<node CREATED="1567927538186" ID="ID_805860522" MODIFIED="1567927546384" TEXT="Binary heap PQ Implementation Details">
<node CREATED="1567927546803" ID="ID_1069320867" MODIFIED="1567927580974" TEXT="Heap sinking and swimming (also called sift down &amp; sift up or bubble up &amp; bubble down"/>
<node CREATED="1567927589436" ID="ID_774595642" MODIFIED="1567927593895" TEXT="Adding elements to PQ"/>
<node CREATED="1567927594246" ID="ID_1621734662" MODIFIED="1567927603643" TEXT="Removing (polling) elements from PQ"/>
<node CREATED="1567949707717" ID="ID_73975884" MODIFIED="1567949717684" TEXT="Ways of Implementing a Priority Queue">
<node CREATED="1567949719213" ID="ID_1547960885" MODIFIED="1567949741532" TEXT="Priority queues are usually implemented with heaps since this gives them the best possible time complexity"/>
<node CREATED="1567949742537" ID="ID_70839202" MODIFIED="1567949804897" TEXT="The Priority Queue (PQ) is an Abstract Data Types (ADT), hence heaps are not the only way to implement PQs. As an example, we could use an unsorted list, but this would not give us the best possible time complexity">
<node CREATED="1567949832983" ID="ID_1495685115" MODIFIED="1567949840485" TEXT="Heaps give best possible time complexity"/>
</node>
</node>
<node CREATED="1567949877188" ID="ID_158494613" MODIFIED="1567949884718" TEXT="Priority Queue With Binary Heap">
<node CREATED="1567949885029" ID="ID_1932206572" MODIFIED="1567949900209" TEXT="There are many types of heaps we could use to implement a priority queue including">
<node CREATED="1567949900424" ID="ID_1358092490" MODIFIED="1567949904168" TEXT="Binary Heap">
<node CREATED="1567949922703" ID="ID_1199673573" MODIFIED="1567949924904" TEXT="simple"/>
<node CREATED="1567949930440" ID="ID_1530505205" MODIFIED="1567949951318" TEXT="A binary heap is a binary tree that supports the heap invariant. In a binary tree every node has exactly two children">
<node CREATED="1567949960743" ID="ID_1496513145" MODIFIED="1567949966323" TEXT="leaves have null children"/>
</node>
<node CREATED="1567949975752" ID="ID_1054380863" MODIFIED="1567950003847" TEXT="A complete binary tree is a tree in which at every level, except possibly the last is completely filled and all the nodes are as far left as possible">
<node CREATED="1567950007801" ID="ID_1005908597" MODIFIED="1567950016988" TEXT="insertion is at bottom left"/>
</node>
<node CREATED="1567950047847" ID="ID_1002203762" MODIFIED="1567950050790" TEXT="Representation">
<node CREATED="1567950051227" ID="ID_357058934" MODIFIED="1567950067878" TEXT="array">
<node CREATED="1567950081493" ID="ID_231498599" MODIFIED="1567950083375" TEXT="insert">
<node CREATED="1567950083598" ID="ID_1781300889" MODIFIED="1567950088488" TEXT="last"/>
</node>
<node CREATED="1567950143938" ID="ID_1058424522" MODIFIED="1567950144949" TEXT="read">
<node CREATED="1567950145308" ID="ID_1623933449" MODIFIED="1567950150514" TEXT="in order"/>
<node CREATED="1567950160664" ID="ID_1355689727" MODIFIED="1567950166928" TEXT="easy to access parents and children">
<node CREATED="1567956289934" ID="ID_1859051456" MODIFIED="1567956295274" TEXT="Let i be the parent node index">
<node CREATED="1567956296089" ID="ID_102512848" MODIFIED="1567956305898" TEXT="left child index: 2i + 1">
<node CREATED="1567956321612" ID="ID_1899068390" MODIFIED="1567956325100" TEXT="zero based"/>
</node>
<node CREATED="1567956306404" ID="ID_983450311" MODIFIED="1567956314219" TEXT="right child index: 2i + 2">
<node CREATED="1567956316858" ID="ID_146825227" MODIFIED="1567956320203" TEXT="zero based"/>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567950091038" ID="ID_1606576895" MODIFIED="1567950096199" TEXT="index tree">
<node CREATED="1567950096755" ID="ID_629510955" MODIFIED="1567950104440" TEXT="not very elegant"/>
</node>
<node CREATED="1567956437211" ID="ID_1089430741" MODIFIED="1567956445105" TEXT="Adding elements to Binary Heap">
<node CREATED="1567956446251" ID="ID_1196345464" MODIFIED="1567956527803">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Step 1: put the new node at bottom left
    </p>
    <p>
      Step 2: bubble up the node
    </p>
    <p>
      &#160;&#160;&#160;&#160;swap with parent
    </p>
    <p>
      &#160;&#160;&#160;&#160;repeat above step until heap invariant is satisfied
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node CREATED="1567956611351" ID="ID_1618022818" MODIFIED="1567956622919" TEXT="Removing elements from Binary heap">
<node CREATED="1567956752227" ID="ID_970781002" MODIFIED="1567956754935" TEXT="Poll()">
<node CREATED="1567956769262" ID="ID_991189842" MODIFIED="1567956772570" TEXT="removing root">
<node CREATED="1567956831611" ID="ID_1330163141" MODIFIED="1567956919255">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Step 1: swap root with rightmost leaf
    </p>
    <p>
      Step 2: remove the rightmost leaf
    </p>
    <p>
      Step 3: bubble down the root (if heap invariant is not satisfied)
    </p>
    <p>
      &#160;&#160;&#160;&#160;swap with smallest child
    </p>
    <p>
      &#160;&#160;&#160;&#160;repeat the above step until heap invariant is satisfied
    </p>
  </body>
</html></richcontent>
<node CREATED="1567957157222" ID="ID_1174713805" MODIFIED="1567957162796" TEXT="O(log(n))"/>
</node>
</node>
</node>
<node CREATED="1567956756128" ID="ID_1212349169" MODIFIED="1567956761487" TEXT="Remove(&lt;element&gt;)">
<node CREATED="1567956974468" ID="ID_3055490" MODIFIED="1567957126776">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Step 1: Search from root to last leaf (O(n))
    </p>
    <p>
      Step 2: Swap the &lt;element&gt; with last leaf
    </p>
    <p>
      Step 3: Remove the last leaf
    </p>
    <p>
      Step 4: Bubble down if possible or bubble up if not
    </p>
    <p>
      &#160;&#160;&#160;&#160;swap with smallest child
    </p>
    <p>
      &#160;&#160;&#160;&#160;repeat the above step until heap invariant is satisfied
    </p>
  </body>
</html></richcontent>
<node CREATED="1567957164165" ID="ID_1636111617" MODIFIED="1567957165678" TEXT="O(n)">
<node CREATED="1567957179682" ID="ID_1820784911" MODIFIED="1567957191310" TEXT="There is a better way to improve to O(log(n))">
<node CREATED="1567957313766" ID="ID_1608366648" MODIFIED="1567957349359" TEXT="The inefficiency of the removal algorithm comes from the fact that we have to perform a linear search to find out where an element is indexed at. What if instead we did a lookup using a Hashtable to find out where a node is indexed at?"/>
<node CREATED="1567957351855" ID="ID_1446472411" MODIFIED="1567957378176" TEXT="A hashtable provides a constant time lookup and update for a mapping from a key (the node value) to a value (the index).">
<node CREATED="1568042442956" ID="ID_1738109903" MODIFIED="1568042450397" TEXT="Every node is mapped to an index"/>
</node>
<node CREATED="1568042460645" ID="ID_273434116" MODIFIED="1568042487498" TEXT="Caveat: What if there are two or more nodes with the same value? What problems would that cause?">
<node CREATED="1568042497356" ID="ID_561055243" MODIFIED="1568042508199" TEXT="Dealing with the multiple value problem">
<node CREATED="1568042509033" ID="ID_1185209261" MODIFIED="1568042555456" TEXT="Instead of mapping one value to one position we will map one value to multiple position. We can maintain a Set or Tree Set of indexes for which a particular node value (key) maps to">
<node CREATED="1568076572310" ID="ID_1143491448" MODIFIED="1568076585145" TEXT="key: node value"/>
<node CREATED="1568076585391" ID="ID_923571877" MODIFIED="1568076594809" TEXT="value: position(s)"/>
<node CREATED="1568076598950" ID="ID_285304010" MODIFIED="1568076601521" TEXT="example">
<node CREATED="1568076602433" ID="ID_1587428585" MODIFIED="1568076667686">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Node Value| Position(s)
    </p>
    <p>
      2&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| 0, 2, 6
    </p>
    <p>
      7&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| 1, 4
    </p>
    <p>
      11&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| 3
    </p>
    <p>
      13&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;| 5
    </p>
  </body>
</html></richcontent>
<node CREATED="1568076708062" ID="ID_31764313" MODIFIED="1568076718362" TEXT="If we swap in tree, we swap in table"/>
</node>
</node>
<node CREATED="1568076736839" ID="ID_51747619" MODIFIED="1568076748170" TEXT="Removing Elements from Binary Heap in O(log(n))">
<node CREATED="1568076749560" ID="ID_1487134193" MODIFIED="1568076771033" TEXT="Question: If we want to remove a repeated node in our heap, which node do we remove and does it matter which one we pick?">
<node CREATED="1568076797580" ID="ID_979531571" MODIFIED="1568076818872" TEXT="Answer: No it doesn&apos;t matter which node we remove as long as we satisfy the heap invariant in the end"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567949904423" ID="ID_1111580034" MODIFIED="1567949908152" TEXT="Fibonacci Heap"/>
<node CREATED="1567949908481" ID="ID_1230783629" MODIFIED="1567949911656" TEXT="Binomial Heap"/>
<node CREATED="1567949911880" ID="ID_358692" MODIFIED="1567949914720" TEXT="Pairing Heap"/>
</node>
</node>
</node>
<node CREATED="1567927605260" ID="ID_1878263323" MODIFIED="1567927609055" TEXT="Code Implementation">
<node CREATED="1568077137995" ID="ID_152980391" MODIFIED="1568077150210" TEXT="Implement Comparable&lt;T&gt;"/>
<node CREATED="1568077259397" ID="ID_879975942" MODIFIED="1568077263101" TEXT="heapify?">
<node CREATED="1568077301604" ID="ID_81292152" MODIFIED="1568077320451" TEXT="construct priority queue using heapify in O(n) time, a great explanation can be found">
<node CREATED="1568077332930" ID="ID_1404815417" MODIFIED="1568077357882" TEXT="http://www.cs.umd.edu/~meesh/351/mount/lectures/lect14-heapsort-analysis-part.pdf"/>
</node>
</node>
<node CREATED="1568077405032" ID="ID_1119387087" MODIFIED="1568077408045" TEXT="isEmpty"/>
<node CREATED="1568077408898" ID="ID_937006672" MODIFIED="1568077410606" TEXT="clear"/>
<node CREATED="1568077413595" ID="ID_340383998" MODIFIED="1568077414885" TEXT="size"/>
<node CREATED="1568077416513" ID="ID_1604124078" MODIFIED="1568077420621" TEXT="peek"/>
<node CREATED="1568077438249" ID="ID_1029750898" MODIFIED="1568077439508" TEXT="poll">
<node CREATED="1568077451719" ID="ID_780690205" MODIFIED="1568077454606" TEXT="return the element"/>
</node>
<node CREATED="1568077457332" ID="ID_1826318537" MODIFIED="1568077458615" TEXT="contains"/>
<node CREATED="1568077524044" ID="ID_1090035191" MODIFIED="1568077524829" TEXT="add"/>
<node CREATED="1568077574028" ID="ID_965458629" MODIFIED="1568077575626" TEXT="less">
<node CREATED="1568077576347" ID="ID_371562966" MODIFIED="1568077581026" TEXT="if nodei &lt;= nodej">
<node CREATED="1568077589949" ID="ID_969149742" MODIFIED="1568077598290" TEXT="implements compareTo method"/>
</node>
</node>
<node CREATED="1568077688819" ID="ID_887344753" MODIFIED="1568077691083" TEXT="sink"/>
<node CREATED="1568077760574" ID="ID_1262028804" MODIFIED="1568077763761" TEXT="swap"/>
<node CREATED="1568077784406" ID="ID_864467679" MODIFIED="1568077788804" TEXT="mapSwap"/>
<node CREATED="1568077799207" ID="ID_557891651" MODIFIED="1568077802526" TEXT="remove"/>
<node CREATED="1568077829858" ID="ID_1790732555" MODIFIED="1568077832060" TEXT="removeAt"/>
<node CREATED="1568077932782" ID="ID_1039253573" MODIFIED="1568077935766" TEXT="isMinHeap">
<node CREATED="1568077939159" ID="ID_226646065" MODIFIED="1568077946158" TEXT="Checks the integrity"/>
</node>
<node CREATED="1568078017846" ID="ID_1084899389" MODIFIED="1568078020080" TEXT="mapAdd"/>
<node CREATED="1568078020407" ID="ID_1575924523" MODIFIED="1568078023528" TEXT="mapRemove">
<node CREATED="1568078026877" ID="ID_1650852955" MODIFIED="1568078032087" TEXT="Uses TreeSet">
<node CREATED="1568078032419" ID="ID_716690057" MODIFIED="1568078041326" TEXT="Balanced Binary Search Tree"/>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047698146" ID="ID_948257874" MODIFIED="1567047705098" TEXT="Min heaps and Max heaps">
<node CREATED="1567928519976" ID="ID_144466936" MODIFIED="1567928541631" TEXT="All heaps must be trees (can have multiple roots)">
<node CREATED="1567928544577" ID="ID_1495467005" MODIFIED="1567928548022" TEXT="no cycles allowed"/>
</node>
</node>
<node CREATED="1567047706464" ID="ID_334392311" MODIFIED="1567047712854" TEXT="Priority queue inserting elements"/>
<node CREATED="1567047714112" ID="ID_1738142256" MODIFIED="1567047721459" TEXT="Priority queue removing elements"/>
<node CREATED="1567047722745" ID="ID_1647223488" MODIFIED="1567047727545" TEXT="Priority queue source code"/>
</node>
<node CREATED="1567047734303" ID="ID_131011986" MODIFIED="1567047742776" POSITION="right" TEXT="Union find/Disjoint set">
<node CREATED="1567047743922" ID="ID_1964427090" MODIFIED="1567047748417" TEXT="Union find introduction">
<node CREATED="1568078144253" ID="ID_1263656862" MODIFIED="1568078147915" TEXT="Outline">
<node CREATED="1568078148124" ID="ID_334747435" MODIFIED="1568078153978" TEXT="Discussion &amp; Examples">
<node CREATED="1568078165779" ID="ID_1537024997" MODIFIED="1568078173275" TEXT="What is Union Find?">
<node CREATED="1568078280690" ID="ID_142617000" MODIFIED="1568078308787" TEXT="Union Find is a data structure that keeps track of elements which are split into one or more disjoint sets. Its has two primary operations: find and union">
<node CREATED="1568078340666" ID="ID_1201785571" MODIFIED="1568078341768" TEXT="find">
<node CREATED="1568078347406" ID="ID_875295430" MODIFIED="1568078360415" TEXT="given an element, it tells what group the element belongs to"/>
</node>
<node CREATED="1568078366312" ID="ID_499729653" MODIFIED="1568078368129" TEXT="union">
<node CREATED="1568078368480" ID="ID_1922498374" MODIFIED="1568078372515" TEXT="merges two groups together"/>
</node>
</node>
</node>
<node CREATED="1568078173514" ID="ID_1608169854" MODIFIED="1568078179323" TEXT="Magnets example">
<node CREATED="1568078393590" ID="ID_421108015" MODIFIED="1568078409494" TEXT="merge closest magnets"/>
</node>
<node CREATED="1568078179571" ID="ID_731290394" MODIFIED="1568078187953" TEXT="When and where is a Union Find used?">
<node CREATED="1568078509369" ID="ID_1978700048" MODIFIED="1568078519549" TEXT="Kruskal&apos;s minimum spanning tree algorithm"/>
<node CREATED="1568078521595" ID="ID_1793837877" MODIFIED="1568078525287" TEXT="Grid percolation">
<node CREATED="1568078569302" ID="ID_484098103" MODIFIED="1568078581823" TEXT="to see if there is a path from bottom of the grid to the top of the grid">
<node CREATED="1568078595697" ID="ID_1156579490" MODIFIED="1568078601964" TEXT="implemented using merging paths"/>
</node>
</node>
<node CREATED="1568078526453" ID="ID_280357038" MODIFIED="1568078531103" TEXT="Network connectivity">
<node CREATED="1568078657736" ID="ID_1666616653" MODIFIED="1568078672700" TEXT="are two vertices in a graph connected to each other through a series of edges"/>
</node>
<node CREATED="1568078531363" ID="ID_17774009" MODIFIED="1568078538217" TEXT="Least common ancestor in trees"/>
<node CREATED="1568078538471" ID="ID_408909853" MODIFIED="1568078542342" TEXT="Image processing"/>
</node>
<node CREATED="1568078189067" ID="ID_184098431" MODIFIED="1568078199618" TEXT="Kruskal&apos;s minimum spanning tree algorithm">
<node CREATED="1568087439143" ID="ID_1282921816" MODIFIED="1568087483552" TEXT="Given a graph G = (V, E) we want to find a Minimum Spanning Tree in the graph (it may not be unique). A minimum spanning tree is a subset of the edges which connect all vertices in the graph with the minimal total edge cost">
<node CREATED="1568087758715" ID="ID_1984689568" MODIFIED="1568087760927" TEXT="Steps">
<node CREATED="1568087761223" ID="ID_1804941219" MODIFIED="1568087849572">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Step 1: Sort edges by ascending edge weight
    </p>
    <p>
      Step 2: Walk through the sorted edges and look at the two nodes the edge belongs to, if the nodes are alrady unified we don't include this edge, otherwise we include it and unify the nodes.
    </p>
    <p>
      Step 3: The algorithm terminates when every edge has been processed or all the vertices have been unified.<br /><br />
    </p>
  </body>
</html></richcontent>
<node CREATED="1568087921481" ID="ID_385307345" MODIFIED="1568087923957" TEXT="example">
<node CREATED="1568087924235" ID="ID_328806408" MODIFIED="1568088010393">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      I to J = 0
    </p>
    <p>
      A to E = 1
    </p>
    <p>
      C to I = 1
    </p>
    <p>
      E to F = 1
    </p>
    <p>
      G to H = 1
    </p>
    <p>
      B to D = 1
    </p>
    <p>
      C to J = 1
    </p>
    <p>
      D to E = 2
    </p>
    <p>
      D to H = 2
    </p>
    <p>
      A to D = 4
    </p>
    <p>
      B to C = 4
    </p>
    <p>
      C to H = 4
    </p>
    <p>
      G to I = 4
    </p>
    <p>
      A to B = 5
    </p>
    <p>
      D to F = 5
    </p>
    <p>
      H to I = 6
    </p>
    <p>
      F to G = 7
    </p>
    <p>
      D to G = 11
    </p>
  </body>
</html></richcontent>
<node CREATED="1568089646180" ID="ID_1425195954" MODIFIED="1568089651342" TEXT="Unify IJ"/>
<node CREATED="1568089657359" ID="ID_711122726" MODIFIED="1568089659817" TEXT="Unify AE"/>
<node CREATED="1568089666354" ID="ID_1383068915" MODIFIED="1568089673633" TEXT="Add CI to IJ group"/>
<node CREATED="1568089678324" ID="ID_892609752" MODIFIED="1568089688374" TEXT="Unify EF"/>
<node CREATED="1568089688936" ID="ID_862850876" MODIFIED="1568089694238" TEXT="Unify GH"/>
<node CREATED="1568089694939" ID="ID_1446212452" MODIFIED="1568089701230" TEXT="Unify BD"/>
<node CREATED="1568089719462" ID="ID_1609339144" MODIFIED="1568089727956" TEXT="Ignore CJ">
<node CREATED="1568089728625" ID="ID_1446072022" MODIFIED="1568089732971" TEXT="Use find"/>
<node CREATED="1568089737576" ID="ID_1645677530" MODIFIED="1568089741531" TEXT="forms cycle"/>
</node>
<node CREATED="1568089742937" ID="ID_1712853685" MODIFIED="1568089760808" TEXT="Add DE to BD">
<node CREATED="1568089761145" ID="ID_1230992962" MODIFIED="1568089763585" TEXT="Use union"/>
</node>
<node CREATED="1568089770447" ID="ID_1050381757" MODIFIED="1568089784823" TEXT="Add HG to DE group"/>
<node CREATED="1568089786784" ID="ID_827166586" MODIFIED="1568089793009" TEXT="Ignore AD"/>
<node CREATED="1568089798826" ID="ID_1776634390" MODIFIED="1568089822541" TEXT="Merge BC to DH group"/>
</node>
</node>
<node CREATED="1568089830605" ID="ID_687747281" MODIFIED="1568089837909" TEXT="Data Structure used">
<node CREATED="1568089838142" ID="ID_272549175" MODIFIED="1568089840805" TEXT="Union-Find">
<node CREATED="1568167048745" ID="ID_580039251" MODIFIED="1568167053957" TEXT="Constructing Union Find">
<node CREATED="1568167055388" ID="ID_1697572879" MODIFIED="1568167119046" TEXT="To begin using Union Find, first construct a bijection (a mapping) between your objects and the integers in the rangle [0, n)."/>
<node CREATED="1568167120207" ID="ID_1831206046" MODIFIED="1568167142902" TEXT="Note: This step is not necessary in general, but it will allow us to construct an array-based union find.">
<node CREATED="1568169826017" ID="ID_1444081750" MODIFIED="1568169828985" TEXT="efficient"/>
<node CREATED="1568169831274" ID="ID_571583936" MODIFIED="1568169834505" TEXT="easy to work with"/>
</node>
<node CREATED="1568169842168" ID="ID_1894178734" MODIFIED="1568169865530" TEXT="Randomly assign a mapping between the objects and the integers on the right">
<node CREATED="1568169878803" ID="ID_932267175" MODIFIED="1568169890180" TEXT="Store mappings in hashtable"/>
</node>
<node CREATED="1568169893955" ID="ID_1329743372" MODIFIED="1568169936641" TEXT="Store Union Find information  in an array. Each index hass an associated object (letter in this example) we can lookup through our mapping">
<node CREATED="1568169992588" ID="ID_1763500310" MODIFIED="1568170075938" TEXT="value in the array is currently the index at which it is">
<node CREATED="1568170078027" ID="ID_943535646" MODIFIED="1568170083676" TEXT="It maps to itself"/>
<node CREATED="1568170092276" ID="ID_969372444" MODIFIED="1568170111606" TEXT="As we group the letters, we change values to the group index">
<node CREATED="1568170120944" ID="ID_908710448" MODIFIED="1568170124188" TEXT="Union(C, K)">
<node CREATED="1568170124502" ID="ID_1961113726" MODIFIED="1568170146152" TEXT="C can be K&apos;s Parent">
<node CREATED="1568170150414" ID="ID_1661794539" MODIFIED="1568170155098" TEXT="Change K -&gt; 4"/>
</node>
</node>
<node CREATED="1568170158920" ID="ID_1680230408" MODIFIED="1568170163434" TEXT="Union(F, E)">
<node CREATED="1568170163866" ID="ID_1445343597" MODIFIED="1568170176946" TEXT="F can be E&apos;s Parent">
<node CREATED="1568170177262" ID="ID_96440245" MODIFIED="1568170183640" TEXT="Change F -&gt; 0"/>
</node>
</node>
<node CREATED="1568170188167" ID="ID_533620574" MODIFIED="1568170192641" TEXT="Union(A, J)">
<node CREATED="1568170192898" ID="ID_1307773254" MODIFIED="1568170205520" TEXT="A can be J&apos;s Parent">
<node CREATED="1568170205725" ID="ID_129488827" MODIFIED="1568170227573" TEXT="Change J -&gt; 6"/>
</node>
</node>
<node CREATED="1568170230356" ID="ID_278221946" MODIFIED="1568170267101" TEXT="Union(A, B)">
<node CREATED="1568170235525" ID="ID_1380066484" MODIFIED="1568170278360" TEXT="A can be B&apos;s Parent">
<node CREATED="1568170284681" ID="ID_1072026598" MODIFIED="1568170292379" TEXT="Change B -&gt; 6"/>
</node>
</node>
<node CREATED="1568170387191" ID="ID_276643491" MODIFIED="1568170392487" TEXT="Union(C, D)">
<node CREATED="1568170392703" ID="ID_630546287" MODIFIED="1568170425685" TEXT="C can be D&apos;s Parent">
<node CREATED="1568170426026" ID="ID_630733983" MODIFIED="1568170432429" TEXT="Change D -&gt; 4"/>
</node>
</node>
<node CREATED="1568170522641" ID="ID_1425954323" MODIFIED="1568170526917" TEXT="Union(D, I)">
<node CREATED="1568170529164" ID="ID_1414334197" MODIFIED="1568170537325" TEXT="C can be I&apos;s Parent">
<node CREATED="1568170538260" ID="ID_490380448" MODIFIED="1568170541916" TEXT="Change I -&gt; 4"/>
</node>
</node>
<node CREATED="1568171192226" ID="ID_1088921374" MODIFIED="1568171196956" TEXT="Union(L, F)"/>
<node CREATED="1568171198248" ID="ID_1383654866" MODIFIED="1568171210996" TEXT="Union(C, A)"/>
<node CREATED="1568171217794" ID="ID_322756246" MODIFIED="1568171222780" TEXT="Union(A, B)"/>
<node CREATED="1568171224538" ID="ID_146280339" MODIFIED="1568171227892" TEXT="Union(H, G)"/>
<node CREATED="1568171229085" ID="ID_223595249" MODIFIED="1568171235043" TEXT="Union(H, F)"/>
<node CREATED="1568171235363" ID="ID_39481054" MODIFIED="1568171243293" TEXT="Union(H, B)"/>
</node>
<node CREATED="1568171138811" ID="ID_387087481" MODIFIED="1568171165567" TEXT="If two trees have to be merged, change value of one root to the value of another root">
<node CREATED="1568171166004" ID="ID_26266615" MODIFIED="1568171177195" TEXT="Rest of the node values remain the same"/>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1568171258383" ID="ID_28291819" MODIFIED="1568171259853" TEXT="Summary">
<node CREATED="1568171262649" ID="ID_1690995910" MODIFIED="1568171266581" TEXT="Find Operation">
<node CREATED="1568171271487" ID="ID_309781133" MODIFIED="1568171302334" TEXT="To find which component a particular element belongs to find the root of that component by following the parent nodes until a self loop is reached (a node who&apos;s parent is itself)">
<node CREATED="1568171332535" ID="ID_1712453442" MODIFIED="1568171344300" TEXT="finds the group to which an element belongs to"/>
</node>
</node>
<node CREATED="1568171267052" ID="ID_1402704936" MODIFIED="1568171270405" TEXT="Union Operation">
<node CREATED="1568171407998" ID="ID_303427068" MODIFIED="1568171432469" TEXT="To unify two elements find which are the root nodes ofeach component and if the root nodes are different make one of the root nodes be the parent of the other."/>
<node CREATED="1568173382570" ID="ID_267697709" MODIFIED="1568173384398" TEXT="Remarks">
<node CREATED="1568173384567" ID="ID_267827479" MODIFIED="1568173411990" TEXT="In this data structure, we do not &quot;un-union&quot; elements. In general, this would be very inefficient to do since we would have to update all the children of a node."/>
<node CREATED="1568173413126" ID="ID_386114053" MODIFIED="1568173439806" TEXT="The number of components is equal to the number of roots remaining. Also, remark that the number of root nodes never increases.">
<node CREATED="1568173523892" ID="ID_1646292101" MODIFIED="1568173531067" TEXT="number or root nodes decreases"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1568078202332" ID="ID_963249453" MODIFIED="1568078206315" TEXT="Complexity analysis">
<node CREATED="1568078728392" ID="ID_1969977949" MODIFIED="1568078732091" TEXT="Construction">
<node CREATED="1568078732812" ID="ID_874446638" MODIFIED="1568078734243" TEXT="O(n)"/>
</node>
<node CREATED="1568078735356" ID="ID_367350127" MODIFIED="1568078736796" TEXT="Union">
<node CREATED="1568078737164" ID="ID_563029446" MODIFIED="1568078741635" TEXT="alpha(n)">
<node CREATED="1568078748884" ID="ID_1933112710" MODIFIED="1568078780534" TEXT="amortized constant time">
<node CREATED="1568173549306" ID="ID_1339263966" MODIFIED="1568173555988" TEXT="This needs path compression">
<node CREATED="1568173559579" ID="ID_391674643" MODIFIED="1568173613826" TEXT="Checking if H and B belong to the same group takes five hops and in the worst case this is potentially much more"/>
</node>
</node>
</node>
</node>
<node CREATED="1568078743323" ID="ID_99415186" MODIFIED="1568078744627" TEXT="Find">
<node CREATED="1568078745048" ID="ID_1312539418" MODIFIED="1568078748179" TEXT="alpha(n)">
<node CREATED="1568078755216" ID="ID_1495561073" MODIFIED="1568078785027" TEXT="amortized constant time"/>
</node>
</node>
<node CREATED="1568078759313" ID="ID_1996246181" MODIFIED="1568078762978" TEXT="Get component size">
<node CREATED="1568078763320" ID="ID_1217236053" MODIFIED="1568078792602" TEXT="alpha(n)">
<node CREATED="1568078792824" ID="ID_381645532" MODIFIED="1568078797480" TEXT="amortized constant time"/>
</node>
</node>
<node CREATED="1568078799027" ID="ID_1062785051" MODIFIED="1568078802714" TEXT="Check if connected">
<node CREATED="1568078802911" ID="ID_694425404" MODIFIED="1568078806178" TEXT="alpha(n)">
<node CREATED="1568078806344" ID="ID_548940453" MODIFIED="1568078810095" TEXT="amortized constant time"/>
</node>
</node>
<node CREATED="1568078811049" ID="ID_251154875" MODIFIED="1568078814193" TEXT="Count components">
<node CREATED="1568078814410" ID="ID_517662786" MODIFIED="1568078817162" TEXT="O(1)"/>
</node>
</node>
</node>
<node CREATED="1568078154267" ID="ID_1975942754" MODIFIED="1568078160021" TEXT="Implementation Details">
<node CREATED="1568078208178" ID="ID_293248170" MODIFIED="1568078213659" TEXT="Find &amp; Union operations"/>
<node CREATED="1568078213897" ID="ID_1007089506" MODIFIED="1568078219098" TEXT="Path compression">
<node CREATED="1568174063005" ID="ID_977710336" MODIFIED="1568174073639" TEXT="Boost in efficiency">
<node CREATED="1568174110369" ID="ID_1136559578" MODIFIED="1568174123076" TEXT="Hypothetical Union find path compression example">
<node CREATED="1568174124047" ID="ID_1777714048" MODIFIED="1568174161645">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      E -&gt; D -&gt; C -&gt; B -&gt; A -&gt; F
    </p>
    <p>
      L -&gt; K -&gt; J -&gt; I -&gt; H -&gt; G
    </p>
  </body>
</html></richcontent>
<node CREATED="1568174171517" ID="ID_309016610" MODIFIED="1568174182385" TEXT="Union(E, L)">
<node CREATED="1568174187825" ID="ID_67655286" MODIFIED="1568174591927">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Step 1: Find root node of E
    </p>
    <p>
      Step 2: Find root node of L
    </p>
    <p>
      Step 3: Point each of the nodes along the path to root node
    </p>
  </body>
</html></richcontent>
<node CREATED="1568174253139" ID="ID_908934707" MODIFIED="1568174263138" TEXT="Lookup of each node in the path is O(1)">
<node CREATED="1568174519005" ID="ID_797992579" MODIFIED="1568174523900" TEXT="Un-unifying is not done"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1568078160250" ID="ID_1673446595" MODIFIED="1568078164690" TEXT="Code Implementation">
<node CREATED="1568341560514" ID="ID_778191565" MODIFIED="1568344215714" TEXT="find"/>
<node CREATED="1568344221121" ID="ID_554616467" MODIFIED="1568344277207" TEXT="connected"/>
<node CREATED="1568344298893" ID="ID_158909535" MODIFIED="1568344302304" TEXT="componentSize"/>
<node CREATED="1568344303472" ID="ID_1908701638" MODIFIED="1568344306312" TEXT="size"/>
<node CREATED="1568344307559" ID="ID_743386586" MODIFIED="1568344309207" TEXT="components"/>
<node CREATED="1568344332018" ID="ID_854394988" MODIFIED="1568344334194" TEXT="unify"/>
</node>
</node>
</node>
<node CREATED="1567047749513" ID="ID_1062175127" MODIFIED="1567047762257" TEXT="Kruskal&apos;s Algorithm"/>
<node CREATED="1567047763675" ID="ID_1745405641" MODIFIED="1567047768833" TEXT="Union and find operations"/>
<node CREATED="1567047770100" ID="ID_1547770058" MODIFIED="1567047773002" TEXT="Path compression"/>
<node CREATED="1567047773953" ID="ID_330957645" MODIFIED="1567047777977" TEXT="Union find source code"/>
</node>
<node CREATED="1567047783841" ID="ID_1909997002" MODIFIED="1567047788346" POSITION="left" TEXT="Binary search trees">
<node CREATED="1567047790041" ID="ID_238808165" MODIFIED="1567047798747" TEXT="Introduction to binary trees">
<node CREATED="1568528410965" ID="ID_780782571" MODIFIED="1568528417465" TEXT="Outline">
<node CREATED="1568528417876" ID="ID_578273971" MODIFIED="1568528421569" TEXT="Discussion &amp; Examples">
<node CREATED="1568528421793" ID="ID_1507477109" MODIFIED="1568528438410" TEXT="What is a Binary Tree (BT)?"/>
<node CREATED="1568528438738" ID="ID_1040614206" MODIFIED="1568528447812" TEXT="What is a Binary Search Tree (BST)?"/>
<node CREATED="1568528448095" ID="ID_1502420837" MODIFIED="1568528455810" TEXT="Where are BTs and BSTs used?"/>
</node>
<node CREATED="1568528460936" ID="ID_1561418467" MODIFIED="1568528466283" TEXT="Complexity Analysis"/>
<node CREATED="1568528484700" ID="ID_450829794" MODIFIED="1568528489540" TEXT="How to insert nodes into a BST"/>
<node CREATED="1568528489749" ID="ID_781519944" MODIFIED="1568528499334" TEXT="Now to remove nodes from a BST"/>
<node CREATED="1568528499560" ID="ID_346963154" MODIFIED="1568528504846" TEXT="Binary tree traversals">
<node CREATED="1568528505527" ID="ID_1225782092" MODIFIED="1568528507830" TEXT="preorder"/>
<node CREATED="1568528508157" ID="ID_1769320940" MODIFIED="1568528509583" TEXT="inorder"/>
<node CREATED="1568528509823" ID="ID_608449963" MODIFIED="1568528512014" TEXT="postorder"/>
<node CREATED="1568528512236" ID="ID_497748654" MODIFIED="1568528517039" TEXT="level order"/>
</node>
<node CREATED="1568528532840" ID="ID_985303800" MODIFIED="1568528539518" TEXT="A glance at some source code"/>
</node>
<node CREATED="1568528551464" ID="ID_1136244000" MODIFIED="1568528558002" TEXT="Discussion and Examples">
<node CREATED="1568528558899" ID="ID_392043351" MODIFIED="1568528565602" TEXT="Quick terminology crash course">
<node CREATED="1568528566257" ID="ID_1070881785" MODIFIED="1568528581451" TEXT="A tree is an undirected graph which satisfies any of the following definitions:">
<node CREATED="1568528584779" ID="ID_1018793476" MODIFIED="1568528596458" TEXT="An acyclic connected graph"/>
<node CREATED="1568528597299" ID="ID_914039256" MODIFIED="1568528606506" TEXT="A connected graph with N nodes and N - 1 edges"/>
<node CREATED="1568528608413" ID="ID_696876704" MODIFIED="1568528623142" TEXT="A graph in which any two vertices are connected by exactly one path">
<node CREATED="1568528641306" ID="ID_563620070" MODIFIED="1568528649448" TEXT="Cannot have multiple paths - cycle"/>
</node>
</node>
<node CREATED="1568528660099" ID="ID_1665752564" MODIFIED="1568528662658" TEXT="Root node">
<node CREATED="1568528663297" ID="ID_963479124" MODIFIED="1568528680426" TEXT="If we have a rooted tree then we will want to have a reference to the root nodes of our tree">
<node CREATED="1568528680876" ID="ID_1766789195" MODIFIED="1568528686745" TEXT="Any node can be a root"/>
</node>
<node CREATED="1568528691513" ID="ID_1063739012" MODIFIED="1568528712675" TEXT="It does not always matter which node is selected to be the root node because any node can root the tree!"/>
</node>
<node CREATED="1568528721178" ID="ID_363931902" MODIFIED="1568528727683" TEXT="Child node">
<node CREATED="1568528727940" ID="ID_1104977958" MODIFIED="1568528744835" TEXT="A child is a node extending from another node. A parent is the inverse of this">
<node CREATED="1568528751543" ID="ID_665242293" MODIFIED="1568528762168" TEXT="parent is a node from with child node(s) extend"/>
</node>
<node CREATED="1568528768762" ID="ID_35594316" MODIFIED="1568528774414" TEXT="What is the parent of the root node?">
<node CREATED="1568528785645" ID="ID_45805256" MODIFIED="1568528814500" TEXT="It has no parent, although it may be useful to assign the parent of the root node to be itself (e.g. filesystem tree).">
<node CREATED="1568528893778" ID="ID_825186751" MODIFIED="1568528904454" TEXT="cd /; cd ../ (outputs /)"/>
</node>
</node>
</node>
<node CREATED="1568528946339" ID="ID_1192297905" MODIFIED="1568528950909" TEXT="Leaf node">
<node CREATED="1568528952694" ID="ID_1968705732" MODIFIED="1568528966636" TEXT="A leaf node is a node with no children. These have been highlighted in orange"/>
</node>
<node CREATED="1568528972663" ID="ID_364296601" MODIFIED="1568528976181" TEXT="Subtree">
<node CREATED="1568528976519" ID="ID_162904226" MODIFIED="1568529000423" TEXT="A subtree is a tree entirely contained within another. They are usually denoted using triangles."/>
<node CREATED="1568529002931" ID="ID_611349863" MODIFIED="1568529013407" TEXT="Note: Subtrees may consist of a single node!"/>
</node>
</node>
<node CREATED="1568528917531" ID="ID_243235990" MODIFIED="1568528919285" TEXT="Example">
<node CREATED="1568528919845" ID="ID_1387744272" MODIFIED="1568528937477" TEXT="0 has two children (3 and 2) and a parent (4)"/>
</node>
</node>
<node CREATED="1568529069731" ID="ID_1104146040" MODIFIED="1568529075806" TEXT="What is a Binary Tree (BT)?">
<node CREATED="1568529076964" ID="ID_1928735510" MODIFIED="1568529088580" TEXT="A binary tree is a tree for which every node has at most two child nodes."/>
</node>
<node CREATED="1568529163530" ID="ID_712947060" MODIFIED="1568529171251" TEXT="What is a Binary Search Tree (BST)?">
<node CREATED="1568529173551" ID="ID_550492167" MODIFIED="1568529195671" TEXT="A binary search tree is a binary tree that satisfies the BST invariant:">
<node CREATED="1568529195980" ID="ID_1799467676" MODIFIED="1568529212592" TEXT="left subtree has smaller elements and right subtree has larger elements">
<node CREATED="1568529254027" ID="ID_1472785313" MODIFIED="1568529255514" TEXT="example">
<node CREATED="1568529256050" ID="ID_155857854" MODIFIED="1568529271730" TEXT="If duplicate values are allowed">
<node CREATED="1568529271971" ID="ID_1366662400" MODIFIED="1568529281363" TEXT="BST operations allow for duplicate values"/>
<node CREATED="1568529286576" ID="ID_74660265" MODIFIED="1568529306490" TEXT="most of the time we are only interested in having unique elements inside our tree"/>
</node>
<node CREATED="1568529358673" ID="ID_421120445" MODIFIED="1568529365243" TEXT="We are not limited to only numbers">
<node CREATED="1568529365501" ID="ID_1676286024" MODIFIED="1568529371988" TEXT="Any element that is comparable"/>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1568529534059" ID="ID_656168981" MODIFIED="1568529541409" TEXT="When and where are Binary Trees used?">
<node CREATED="1568529541632" ID="ID_1575863214" MODIFIED="1568529548615" TEXT="Binary Search Trees (BSTs)">
<node CREATED="1568529549416" ID="ID_336043989" MODIFIED="1568529557702" TEXT="Implementation of some map and set ADTs"/>
<node CREATED="1568529559312" ID="ID_1174279347" MODIFIED="1568529562559" TEXT="Red Black Trees"/>
<node CREATED="1568529563820" ID="ID_1406217836" MODIFIED="1568529566479" TEXT="AVL Trees">
<node CREATED="1568529664169" ID="ID_1326705468" MODIFIED="1568529666881" TEXT="Balanced"/>
</node>
<node CREATED="1568529567332" ID="ID_900882476" MODIFIED="1568529569567" TEXT="Splay Trees"/>
<node CREATED="1568529570349" ID="ID_117773364" MODIFIED="1568529571375" TEXT="..."/>
</node>
<node CREATED="1568529587802" ID="ID_1020963841" MODIFIED="1568529593976" TEXT="Used in the implementation of binary heaps"/>
<node CREATED="1568529597182" ID="ID_1529026995" MODIFIED="1568529607373" TEXT="Syntax trees (used by compiler and calculators)">
<node CREATED="1568529674034" ID="ID_1334765232" MODIFIED="1568529679930" TEXT="Parsing arithmetic expression">
<node CREATED="1568529680635" ID="ID_55681848" MODIFIED="1568529687602" TEXT="Place in abstract syntax tree"/>
</node>
</node>
<node CREATED="1568529608211" ID="ID_469372867" MODIFIED="1568529620357" TEXT="Treap - a probabilistic DS (uses a randomized BST)"/>
</node>
<node CREATED="1568529713086" ID="ID_772814655" MODIFIED="1568529718519" TEXT="Complexity of BSTs">
<node CREATED="1568529718827" ID="ID_958549267" MODIFIED="1568529723007" TEXT="insert">
<node CREATED="1568529723719" ID="ID_944966390" MODIFIED="1568529726398" TEXT="O(log(n))">
<node CREATED="1568529733720" ID="ID_781705651" MODIFIED="1568529739222" TEXT="Average time complexity"/>
</node>
<node CREATED="1568529762351" ID="ID_63214156" MODIFIED="1568529765744" TEXT="O(n)">
<node CREATED="1568529766056" ID="ID_533105012" MODIFIED="1568529769488" TEXT="Worst case"/>
</node>
</node>
<node CREATED="1568529727451" ID="ID_1386661459" MODIFIED="1568529729271" TEXT="delete">
<node CREATED="1568529729525" ID="ID_217110308" MODIFIED="1568529732927" TEXT="O(log(n))"/>
<node CREATED="1568529770857" ID="ID_443271952" MODIFIED="1568529773072" TEXT="O(n)">
<node CREATED="1568529773402" ID="ID_1720428557" MODIFIED="1568529776183" TEXT="Worst case"/>
</node>
</node>
<node CREATED="1568529744576" ID="ID_1381137061" MODIFIED="1568529746022" TEXT="remove">
<node CREATED="1568529746409" ID="ID_853206873" MODIFIED="1568529749551" TEXT="O(log(n))"/>
<node CREATED="1568529782167" ID="ID_1342630894" MODIFIED="1568529783967" TEXT="O(n)">
<node CREATED="1568529784607" ID="ID_970857815" MODIFIED="1568529786495" TEXT="Worst case"/>
</node>
</node>
<node CREATED="1568529750486" ID="ID_3004114" MODIFIED="1568529751968" TEXT="search">
<node CREATED="1568529752214" ID="ID_826174695" MODIFIED="1568529754848" TEXT="O(log(n))"/>
<node CREATED="1568529788941" ID="ID_1506658700" MODIFIED="1568529790344" TEXT="O(n)">
<node CREATED="1568529790656" ID="ID_648847970" MODIFIED="1568529792392" TEXT="Worst case"/>
</node>
</node>
</node>
</node>
<node CREATED="1567047799767" ID="ID_1131461627" MODIFIED="1567047805635" TEXT="Binary search tree insertions">
<node CREATED="1568573922905" ID="ID_1927978971" MODIFIED="1568573928595" TEXT="Adding elements to a BST">
<node CREATED="1568573930118" ID="ID_735363289" MODIFIED="1568573947507" TEXT="Binary Search Tree (BST) elements must be comparable so that we cannot order them inside the tree"/>
<node CREATED="1568573952458" ID="ID_386134655" MODIFIED="1568573982965" TEXT="When inserting an element we want to compare its value to the value stored in the current node we&apos;re considering to decide on one of the following:">
<node CREATED="1568573995110" ID="ID_1576644693" MODIFIED="1568574008270" TEXT="Recurse down left subtree (&lt; case)"/>
<node CREATED="1568574008619" ID="ID_1088655444" MODIFIED="1568574019312" TEXT="Recurse down right subtree (&gt; case)"/>
<node CREATED="1568574019823" ID="ID_42389156" MODIFIED="1568574028758" TEXT="Handle finding a duplicate value (= case)">
<node CREATED="1568574218414" ID="ID_1727983030" MODIFIED="1568574222954" TEXT="Add duplicate or ignore">
<node CREATED="1568574353241" ID="ID_1124764950" MODIFIED="1568574361299" TEXT="Choose either left or right and insert"/>
</node>
</node>
<node CREATED="1568574030055" ID="ID_772926372" MODIFIED="1568574038158" TEXT="Construct a new node (found a null leaf)">
<node CREATED="1568574242630" ID="ID_1744987440" MODIFIED="1568574246782" TEXT="If null node is hit"/>
</node>
</node>
</node>
<node CREATED="1568574298043" ID="ID_858739085" MODIFIED="1568574304125" TEXT="Start at root when inserting">
<node CREATED="1568574403561" ID="ID_1397051731" MODIFIED="1568574405297" TEXT="Example">
<node CREATED="1568574405540" ID="ID_1504360597" MODIFIED="1568574450401">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      insert(7)
    </p>
    <p>
      insert(20)
    </p>
    <p>
      insert(5)
    </p>
    <p>
      insert(15)
    </p>
    <p>
      insert(10)
    </p>
    <p>
      insert(4)
    </p>
    <p>
      insert(4)
    </p>
    <p>
      insert(33)
    </p>
    <p>
      insert(2)
    </p>
    <p>
      insert(25)
    </p>
    <p>
      insert(6)
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node CREATED="1568574473084" ID="ID_244751343" MODIFIED="1568574477750" TEXT="Worst case example">
<node CREATED="1568574478041" ID="ID_1232290242" MODIFIED="1568574502930">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      insert(1)
    </p>
    <p>
      insert(2)
    </p>
    <p>
      insert(3)
    </p>
    <p>
      insert(4)
    </p>
    <p>
      insert(5)
    </p>
    <p>
      insert(6)
    </p>
  </body>
</html></richcontent>
<node CREATED="1568574515004" ID="ID_1379986102" MODIFIED="1568574522577" TEXT="takes linear time">
<node CREATED="1568574524690" ID="ID_1077835708" MODIFIED="1568574527121" TEXT="solution">
<node CREATED="1568574527341" ID="ID_555961881" MODIFIED="1568574533558" TEXT="balanced binary search trees"/>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047806769" ID="ID_1637447282" MODIFIED="1567047811993" TEXT="Binary search tree removals">
<node CREATED="1568680839649" ID="ID_1621802069" MODIFIED="1568680849030" TEXT="Removing elements from a BST">
<node CREATED="1568680849533" ID="ID_448812915" MODIFIED="1568680869400" TEXT="Removing elements from a Binary Search Tree (BST) can be seen as a two step process">
<node CREATED="1568680871295" ID="ID_520092863" MODIFIED="1568681480835">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <ol>
      <li>
        Find the element we wish to remove (if it exists)
      </li>
      <li>
        Replace the node we want to remove with its successor (if any) to maintain the BST invariant.
      </li>
    </ol>
  </body>
</html></richcontent>
<node CREATED="1568681482430" ID="ID_122331550" MODIFIED="1568681500116" TEXT="BST invariant: left subtree has smaller elements and right subtree has larger elements"/>
<node CREATED="1576461481630" ID="ID_63782140" MODIFIED="1576461485399" TEXT="Find Phase">
<node CREATED="1576461486007" ID="ID_14717728" MODIFIED="1576461513854" TEXT="When searching our BST for a node with a particular value one of four things can happen">
<node CREATED="1576461515237" ID="ID_462665047" MODIFIED="1576461528344" TEXT="1. We hit a null node at which point we know the value does not exist within out BST">
<node CREATED="1576461734158" ID="ID_987362887" MODIFIED="1576461738450" TEXT="Value does not exist"/>
</node>
<node CREATED="1576461528588" ID="ID_1746345004" MODIFIED="1576461538734" TEXT="2. Comparator value equal to 0 (found it!)">
<node CREATED="1576461749307" ID="ID_1919631078" MODIFIED="1576461754490" TEXT="comparator()"/>
</node>
<node CREATED="1576461538997" ID="ID_516582642" MODIFIED="1576461557302" TEXT="Comparator value less than 0 (the value, if it exists, is in the left subtree)"/>
<node CREATED="1576461557992" ID="ID_1243458320" MODIFIED="1576461574920" TEXT="4. Comparator value greater than 0 (the value, if it exists, is in the right subtree)"/>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1569810446966" ID="ID_1888254347" MODIFIED="1569810451066" TEXT="Find phase">
<node CREATED="1569810451308" ID="ID_157612766" MODIFIED="1569810472742" TEXT="When searching our BST for a node with a particular value one of four things will happen:">
<node CREATED="1569810473200" ID="ID_1901590796" MODIFIED="1569810488138" TEXT="1. We hit a null node at which point we know the value does not exist withing our BST"/>
</node>
</node>
<node CREATED="1576461889023" ID="ID_920480280" MODIFIED="1576461893037" TEXT="Remove Phase">
<node CREATED="1576461893947" ID="ID_672362687" MODIFIED="1576461900162" TEXT="Node to remove is a leaf node">
<node CREATED="1576461935351" ID="ID_952482166" MODIFIED="1576461940543" TEXT="Case I: Leaf Node">
<node CREATED="1576461941853" ID="ID_1048945303" MODIFIED="1576461962648" TEXT="If the node we wish to remove is a leaf node then we may do so without side effect"/>
<node CREATED="1576461964016" ID="ID_1095662322" MODIFIED="1576461991210" TEXT="Suppose we want to remove 8 from the BST on the right. First we would find 8 then remove it immediately since it&apos;s a leaf node"/>
</node>
</node>
<node CREATED="1576461900632" ID="ID_661337218" MODIFIED="1576461910025" TEXT="Node to remove has a right subtree but no left subtree">
<node CREATED="1576462015104" ID="ID_1815376648" MODIFIED="1576462027300" TEXT="Case II &amp; III: either the left/right child node is a subtree">
<node CREATED="1576462033764" ID="ID_1275260460" MODIFIED="1576462051005" TEXT="The successor of the node we are trying to remove in these cases will be the root node of the left/right subtree"/>
<node CREATED="1576462063121" ID="ID_1181855354" MODIFIED="1576462087797" TEXT="It may be the case that you are removing the root node of the BST in which case its immediate child becomes the new root as you would expect.">
<node CREATED="1576462955506" ID="ID_51377550" MODIFIED="1576462959628" TEXT="Remove phase">
<node CREATED="1576462960449" ID="ID_359262930" MODIFIED="1576462975971" TEXT="Suppose we wish to remove 9, then we encounter case II with a left subtree">
<node CREATED="1576463013689" ID="ID_1530898959" MODIFIED="1576463023051" TEXT="Replace 9 with left subtree"/>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1576461910236" ID="ID_686947562" MODIFIED="1576461920505" TEXT="Node to remove has a left subtree but no right subtree"/>
<node CREATED="1576461920719" ID="ID_1735541905" MODIFIED="1576461931998" TEXT="Node to remove has a both left subtree and a right subtree">
<node CREATED="1576463067025" ID="ID_1518852286" MODIFIED="1576463079246" TEXT="Case IV: Node to remove has both a left subtree and a right subtee">
<node CREATED="1576463079964" ID="ID_1701814472" MODIFIED="1576463093810" TEXT="Q: In which subtree will the successor of the node we are trying to remove be?">
<node CREATED="1576463100881" ID="ID_363204097" MODIFIED="1576463127343" TEXT="A: The answer is both! The successor can eiher be the largest value is left subtree or the smallest value in the right subtree">
<node CREATED="1576463285961" ID="ID_49461250" MODIFIED="1576463299600" TEXT="A justification for why there could be more than one successor is:">
<node CREATED="1576464632357" ID="ID_439636528" MODIFIED="1576464647152" TEXT="The largest value in the left subtree satisfies the BST invriant since it:">
<node CREATED="1576464648159" ID="ID_1376997341" MODIFIED="1576464678568" TEXT="Is larger than everything in left subtree. This follows immediately from teh deefinition of being the largest."/>
<node CREATED="1576464679281" ID="ID_1008873799" MODIFIED="1576464703032" TEXT="Is smaller than everything in right subtree because it was found in the left subtree"/>
</node>
<node CREATED="1576464738650" ID="ID_1023946656" MODIFIED="1576464754252" TEXT="The smallest value in the righ subtree satsifies the BST invariant since it:">
<node CREATED="1576464754651" ID="ID_98688016" MODIFIED="1576464778292" TEXT="Is smaller than everything in right subtree. This follows immediately from the definition of being the smallest"/>
<node CREATED="1576464778868" ID="ID_897526518" MODIFIED="1576464791442" TEXT="Is larger than everything in left subtree because it was found in teh right subtree"/>
<node CREATED="1576464791901" ID="ID_233235353" MODIFIED="1576464800365" TEXT="So there are two possible successors, yea!"/>
</node>
</node>
<node CREATED="1576464851491" ID="ID_390127912" MODIFIED="1576464856565" TEXT="We can choose either">
<node CREATED="1576464879132" ID="ID_1203013670" MODIFIED="1576464881989" TEXT="Convension">
<node CREATED="1576464934477" ID="ID_598464022" MODIFIED="1576464947202" TEXT="May need to be done recursively">
<node CREATED="1576465024810" ID="ID_350893117" MODIFIED="1576465043623" TEXT="Case I &gt; Case II or Case III &gt; Case IV"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1576461808520" ID="ID_1347775802" MODIFIED="1576461811457" TEXT="Example:">
<node CREATED="1576461811897" ID="ID_468406332" MODIFIED="1576461837560">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Find queries:
    </p>
    <p>
      find(14)
    </p>
    <p>
      find(25)
    </p>
    <p>
      find(37)
    </p>
    <p>
      find(17)
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node CREATED="1567047812980" ID="ID_194906046" MODIFIED="1567047818554" TEXT="Binary tree traversals">
<node CREATED="1576465288735" ID="ID_1752451947" MODIFIED="1576465299337" TEXT="Preorder, Inorder, Postorder &amp; Level order">
<node CREATED="1576465737369" ID="ID_1389316316" MODIFIED="1576465746420" TEXT="Recursively defined">
<node CREATED="1576465746789" ID="ID_1867325297" MODIFIED="1576465795464">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      preorder(node):
    </p>
    <p>
      &#160;&#160;&#160;&#160;if node == null: return
    </p>
    <p>
      &#160;&#160;&#160;&#160;print(node.value)
    </p>
    <p>
      &#160;&#160;&#160;&#160;preorder(node.left)
    </p>
    <p>
      &#160;&#160;&#160;&#160;preorder(node.right)
    </p>
    <p>
      &#160;&#160;&#160;
    </p>
  </body>
</html></richcontent>
<node CREATED="1576465974504" ID="ID_1798276195" MODIFIED="1576465981728" TEXT="preorder prints before the recursive calls"/>
</node>
<node CREATED="1576465882978" ID="ID_224051724" MODIFIED="1576465927189">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      inorder(node):
    </p>
    <p>
      &#160;&#160;&#160;&#160;if node == null: return
    </p>
    <p>
      &#160;&#160;&#160;&#160;inorder(node.left)
    </p>
    <p>
      &#160;&#160;&#160;&#160;print(node.value)
    </p>
    <p>
      &#160;&#160;&#160;&#160;inorder(node.right)
    </p>
  </body>
</html></richcontent>
<node CREATED="1576466616583" ID="ID_1537868948" MODIFIED="1576466625668" TEXT="inorder prints between the recursive calls"/>
</node>
<node CREATED="1576465930831" ID="ID_1557013778" MODIFIED="1576465968941">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      postorder(node):
    </p>
    <p>
      &#160;&#160;&#160;&#160;if node == null: return
    </p>
    <p>
      &#160;&#160;&#160;&#160;postorder(node.left)
    </p>
    <p>
      &#160;&#160;&#160;&#160;postorder(node.right)
    </p>
    <p>
      &#160;&#160;&#160;&#160;print(node.value)
    </p>
  </body>
</html></richcontent>
<node CREATED="1576466626823" ID="ID_558349930" MODIFIED="1576466637195" TEXT="postorder prints after the recursive calls">
<node CREATED="1576467243398" ID="ID_655833740" MODIFIED="1576467372771">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Call Stack:
    </p>
    <p>
      node A
    </p>
    <p>
      node B
    </p>
    <p>
      node D
    </p>
    <p>
      node I
    </p>
    <p>
      
    </p>
    <p>
      Order: A, B, D, H, I&#160;
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node CREATED="1576551909520" ID="ID_1037845328" MODIFIED="1576551914682" TEXT="Inorder traversal">
<node CREATED="1576551915071" ID="ID_1938042881" MODIFIED="1576551930345" TEXT="Prints values in-order - increasing order"/>
</node>
</node>
<node CREATED="1576552049869" ID="ID_1575590025" MODIFIED="1576552056798" TEXT="Level Order Traversal">
<node CREATED="1576552058767" ID="ID_767845064" MODIFIED="1576552072362" TEXT="In a level order traversal we want to print the nodes as they appear one layer at a time">
<node CREATED="1576552101378" ID="ID_1666245098" MODIFIED="1576552116284" TEXT="To obtain this ordering we want to do a BFS from the root node down to the leaf nodes">
<node CREATED="1576552123896" ID="ID_1589099867" MODIFIED="1576552137587" TEXT="To do a BFS we will need to maintain a Queue of the nodes left to explore"/>
<node CREATED="1576552139032" ID="ID_1074244951" MODIFIED="1576552170747" TEXT="Begin with the root inside of the queue and finish when the queue is empty">
<node CREATED="1576552180219" ID="ID_10089081" MODIFIED="1576552203862" TEXT="Steps: At each iteration we add the left child and the right child of the current node to our queue"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047819640" ID="ID_600226500" MODIFIED="1567047827032" TEXT="Binary search tree source code">
<node CREATED="1576552408502" ID="ID_1963818458" MODIFIED="1576594782743">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      <font size="1">public class BinarySearchTree &lt;T extends Comparable&lt;T&gt;&gt; { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Tracks the number of nodes in this BST </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private int nodeCount = 0; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// This BST is a rooted tree so we maintain a handle on the root node </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private Node root = null; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Internal node containing node references </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// and the actual node data </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private class Node { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;T data; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Node left, right; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;public Node (Node left, Node right, T elem) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;this.data = elem; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;this.left = left; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;this.right = right; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Check if this binary tree is empty </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public boolean isEmpty() { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return size() == 0; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Get the number of nodes in this binary tree </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public int size() { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return nodeCount; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Add an element to this binary tree. Returns true </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// if we successfully perform an insertion </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public boolean add(T elem) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Check if the value already exists in this </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// binary tree, if it does ignore adding it </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (contains(elem)) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false; </font>
    </p>
    <p>
      <font size="1">&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Otherwise add this element to the binary tree </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;root = add(root, elem); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nodeCount++; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Private method to recursively add a value in the binary tree </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;private Node add(Node node, T elem) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Base case: found a leaf node </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (node == null) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node = new Node(null, null, elem); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Place lower elements values in left subtree </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (elem.compareTo(node.data) &lt; 0) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node.left = add(node.left, elem); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node.right = add(node.right, elem); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return node; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Remove a value from this binary tree, if it exists </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;public boolean remove(T elem) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Make sure the node we want to remove </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// actually exists before we remove it </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (contains(elem)) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;root = remove(root, elem); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nodeCount--; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;private Node remove(Node node, T elem) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (node == null) return null; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int cmp = elem.compareTo(node.data); </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Dig into left subtree, the value we're looking </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// for is smaller than the current value </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (cmp &lt; 0) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node.left = remove(node.left, elem); </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Dig into right subtree, the value we're looking </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// for is greater than the current value </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else if (cmp &gt; 0) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node.right = remove(node.right, elem); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Found the node we wish to remove </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// This is the case with only a right subtree or </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// no subtree at all. In this situation just </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// swap the node we wish to remove with its right child. </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (node.left == null) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Node rightChild = node.right; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node.data = null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node = null; </font>
    </p>
    <p>
      <font size="1">&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return rightChild; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// This is the case with only a left subtree or </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// no subtree at all. In this situation just </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// swap the node we wish to remove with its left child. </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else if (node.right == null) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Node leftChild = node.left; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node.data = null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node = null; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return leftChild; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// When removing a node from a binary tree with two links th </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// successor of the node being removed can either be the largest </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// value in the left subtree or the smallest value in the right </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// subtree. In this implementation I have decided to find the </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// smallest value in the right subtree which can be found by </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// traversing as far as possible in the right subtree. </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else { </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Find the leftmost node in the right subtree </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Node tmp = digLeft(node.right); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Swap the data </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node.data = tmp.data; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Go into the right subtree and remove the leftmost node we </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// found and swapped data with. This prevents us from having </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// two nodes in our tree with the same value. </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node.right = remove(node.right, tmp.data); </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// If instead we wanted to find the largest node in the left </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// subtree as opposed to smallest node in the right subtree </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// here is what we do: </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Node tmp = digRight(node.left); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// node.data = tmp.data; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// node.left = remove(node.left, tmp.data);&#160;&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return node; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Helper method to find the leftmost node </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;private Node digLeft(Node node) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Node cur = node; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (cur.left != null) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cur = cur.left; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return cur; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Helper method to find the leftmost node </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;private Node digRight(Node node) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Node cur = node; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (cur.right != null) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cur = cur.right; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return cur; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// returns true if the element exists in the tree </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;public boolean contains(T elem) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return contains(root, elem); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// private recursive method to find an element in the tree </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;private boolean contains(Node node, T elem) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Base case: reached bottom, value not found </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (node == null) return false; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int cmp = elem.compareTo(node.data); </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Dig into the left subtree because the value we're </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// looking for is smaller than the current value </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (cmp &lt; 0) return contains(node.left, elem); </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Dig into the right subtree because the value we're </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// looking for is greater than the current value </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (cmp &gt; 0) return contains(node.right, elem); </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// We found the value we were looking for </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else return true; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Computes the height of the tree, O(n) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;public int height() { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return height(root); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Recursive helper method to compute the height of the tree </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;private int height(Node node) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (node == null) return 0; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return Math.max(height(node.left), height(node.right)) + 1; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// This method returns an iterator for a given TreeTraversalOrder. </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// The ways in which you can traverse the tree are four different ways </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// preorder, inorder, postorder and levelorder. </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;public java.util.Iterator &lt;T&gt; traverse(TreeTraversalOrder order) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;switch (order) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case PRE_ORDER: return preOrderTraversal(); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case IN_ORDER: return inOrderTraversal(); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case POST_ORDER: return postOrderTraversal(); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case LEVEL_ORDER: return levelOrderTraversal(); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;default: return null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Returns as iterator to traverse the tree in pre order </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;private java.util.Iterator &lt;T&gt; preOrderTraversal() { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;}</font>
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node CREATED="1567047834200" ID="ID_1076354860" MODIFIED="1567047836627" POSITION="right" TEXT="Hash tables">
<node CREATED="1567047838699" ID="ID_498331933" MODIFIED="1567047843888" TEXT="Hash table hash functions">
<node CREATED="1576719071204" ID="ID_1737571070" MODIFIED="1576719391418">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Outline
    </p>
    <ol>
      <li>
        What is a Hash Table (HT) and what is a hash function?
      </li>
      <li>
        Properties of hash functions
      </li>
      <li>
        Discussion on collision resolution methods, in particular: separate chaining and open addressing
      </li>
      <li>
        Complexity analysis
      </li>
      <li>
        Separate chaining implementation details:

        <ol>
          <li>
            Linked list approach overview
          </li>
          <li>
            Separate chaining FAQs
          </li>
          <li>
            Separate chaining source code
          </li>
        </ol>
      </li>
      <li>
        Separate chaining HT source code
      </li>
      <li>
        Open addressing techniques implementation details:

        <ol>
          <li>
            Linear probing

            <ol>
              <li>
                What is linear probing?
              </li>
              <li>
                Chaos with cycles
              </li>
              <li>
                Linear probing insertion examples
              </li>
              <li>
                Table resizing and updating values
              </li>
            </ol>
          </li>
          <li>
            Quadratic probing

            <ol>
              <li>
                What is quadratic probing?
              </li>
              <li>
                Problems with probing sequence cycles
              </li>
              <li>
                Different ways to quadratically probe
              </li>
              <li>
                Inserting/ resize examples
              </li>
            </ol>
          </li>
        </ol>
      </li>
      <li>
        Double hashing

        <ol>
          <li>
            What is double hashing? How does it work?
          </li>
          <li>
            Chaos with cycles
          </li>
          <li>
            Constructing a new hash function

            <ol>
              <li>
                Universal hash functions
              </li>
            </ol>
          </li>
          <li>
            Inserting/ resize example
          </li>
        </ol>
      </li>
      <li>
        Removing elements

        <ol>
          <li>
            Solution using tomstones
          </li>
          <li>
            Lazy deletion/ relocation
          </li>
          <li>
            Lots of examples
          </li>
        </ol>
      </li>
      <li>
        Source code!
      </li>
    </ol>
  </body>
</html></richcontent>
</node>
<node CREATED="1576719409990" ID="ID_1774369679" MODIFIED="1576719416996" TEXT="What is a hash table?">
<node CREATED="1576719417243" ID="ID_1459234231" MODIFIED="1576719441447" TEXT="A hash table (HT) is a data structure that provides a mapping from keys to values using a technique calling hashing.">
<node CREATED="1576719481432" ID="ID_1442243528" MODIFIED="1576719537337">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      key (name) -&gt; value (fav color)
    </p>
    <p>
      &quot;William&quot; -&gt; &quot;green&quot;
    </p>
    <p>
      &quot;Micah&quot; -&gt; &quot;purple&quot;
    </p>
    <p>
      &quot;Catherine&quot; -&gt; &quot;yellow&quot;
    </p>
    <p>
      &quot;Thomas&quot; -&gt; &quot;red&quot;
    </p>
    <p>
      &quot;Leah&quot; -&gt; &quot;purple&quot;
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node CREATED="1576719542482" ID="ID_353482957" MODIFIED="1576719549546" TEXT="We refer to these as key-value pairs"/>
<node CREATED="1576719550849" ID="ID_928593708" MODIFIED="1576719560671" TEXT="Keys must be unique, but values can be repeated"/>
<node CREATED="1576719592181" ID="ID_590492122" MODIFIED="1576719615250" TEXT="HTs are often used to track item frequencies. For instance, coutning the number of times a word appears in a given text."/>
<node CREATED="1576719667099" ID="ID_1449510494" MODIFIED="1576719697130" TEXT="The key-value pairs you can place in a HT can be of any type not just strings and numbers, but also bojects! However, the keys needs to be hashable, a property we will discuss shortly">
<node CREATED="1576719707058" ID="ID_873018824" MODIFIED="1576719732321" TEXT="To be able to understand how a mapping is constructed between key-value pairs we fist need to talk about hash functions."/>
<node CREATED="1576719732567" ID="ID_1959597115" MODIFIED="1576719747809" TEXT="A hash function H(x) is a function that maps a key &apos;x&apos; to a whole number in a fixed range.">
<node CREATED="1576719751627" ID="ID_1160981104" MODIFIED="1576719786554" TEXT="Example: H(x) = (x^2 - 6x + 9) mod 10 maps all integer keys to the range [0, 9]">
<node CREATED="1576719794298" ID="ID_1324821729" MODIFIED="1576719938680">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      H(4) = (16 - 24 + 9) mod 10 = 1
    </p>
    <p>
      H(-7) = (49 + 42 + 9) mod 10 = 0
    </p>
    <p>
      H(0) = (0 - 0 + 9) mod 10 = 9
    </p>
    <p>
      H(2) = (4 - 12 + 9) mod 10 = 1
    </p>
    <p>
      H(8) = (64 - 48 + 9) mod 10 = 5
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node CREATED="1576719981847" ID="ID_324076642" MODIFIED="1576720006195" TEXT="We can also define hash functions for arbitrary objects such as strings, list, tuples, multi data objects, etc...">
<node CREATED="1576720017235" ID="ID_260903345" MODIFIED="1576720037487" TEXT="For a string s let H(s) be a hash function defined below where ASCII(x) returns the ASCII valeu fo the character x">
<node CREATED="1576720040853" ID="ID_881056835" MODIFIED="1576720077379">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      ASCII('A') = 65
    </p>
    <p>
      ASCII('B') = 66
    </p>
    <p>
      ...
    </p>
    <p>
      ASCII('Z') = 90
    </p>
  </body>
</html></richcontent>
</node>
<node CREATED="1576720080138" ID="ID_309025568" MODIFIED="1576720129560">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      function H(s):
    </p>
    <p>
      &#160;&#160;&#160;&#160;sum := 0
    </p>
    <p>
      &#160;&#160;&#160;&#160;for char in x:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sum = sum + ASCII(char)
    </p>
    <p>
      &#160;&#160;&#160;&#160;return sum mod 50
    </p>
  </body>
</html></richcontent>
</node>
<node CREATED="1576720271210" ID="ID_1995836199" MODIFIED="1576720289259" TEXT="There are an infinite number of possible valid hash functions H(person), here is one:">
<node CREATED="1576720290849" ID="ID_1284309586" MODIFIED="1576720340812">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      function H(person):
    </p>
    <p>
      &#160;&#160;&#160;&#160;hash := person.age
    </p>
    <p>
      &#160;&#160;&#160;&#160;hash = hash + length(person.name)
    </p>
    <p>
      &#160;&#160;&#160;&#160;if person.sex == &quot;M&quot;:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hash = hash + 1
    </p>
    <p>
      &#160;&#160;&#160;&#160;return hash mod 6
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1576720397304" ID="ID_585727740" MODIFIED="1576720403401" TEXT="Properties of Hash functions">
<node CREATED="1576720403810" ID="ID_146175552" MODIFIED="1576720434098" TEXT="If H(x) = H(y) then objects x and y might be equal, but if H(x) != H(y) then x and y are certainly not equal">
<node CREATED="1576720484417" ID="ID_680162370" MODIFIED="1576720497064" TEXT="Q: How can we use this to our advantage to speedup object comparisons?">
<node CREATED="1576720505225" ID="ID_1898076730" MODIFIED="1576720538716" TEXT="A: This means that instead of comparing x and y directly a smarter approach is to first compare their hash values, and only if the hash values match do we nedd to explicitly compare xa nd y."/>
<node CREATED="1576721967580" ID="ID_304807664" MODIFIED="1576721987476" TEXT="Consider the problem of trying to determine if two very large files have the same contents."/>
<node CREATED="1576721987977" ID="ID_643451174" MODIFIED="1576722066926" TEXT="If we precomputed H(file1) and H(file2) first we should compare those hash values since comparing hash values is O(1)! If possible, we do not want to open either of the files directly. Comparing their contents can be very slow, although we may have to if H(file1) = H(file2).">
<node CREATED="1576722069556" ID="ID_638934834" MODIFIED="1576722103324" TEXT="NOTE: Hash functions for files are more sophisticated than those used for hashtables. Instead for files we use what are called cryptographic hash functions also called checksums"/>
</node>
<node CREATED="1576722202495" ID="ID_1558704010" MODIFIED="1576722213024" TEXT="A hash function H(x) must be deterministic.">
<node CREATED="1576722214705" ID="ID_1807800955" MODIFIED="1576722254468" TEXT="This means that if H(x) = y then H9x) must always produce y and never another value.. This may be seen as obvious, but it is critical to the functionality of a hash function.">
<node CREATED="1576722259505" ID="ID_923968337" MODIFIED="1576722270754" TEXT="Example of non-deterministic hash functions:">
<node CREATED="1576722271010" ID="ID_1309489189" MODIFIED="1576722298798">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      counter := 0
    </p>
    <p>
      function H(x):
    </p>
    <p>
      &#160;&#160;&#160;&#160;counter = counter + 1
    </p>
    <p>
      &#160;&#160;&#160;&#160;return (x + counter) mod 13
    </p>
  </body>
</html></richcontent>
<node CREATED="1576722300228" ID="ID_1536661597" MODIFIED="1576722324692" TEXT="H(5) = 6 but H(5) = 7 as well"/>
</node>
</node>
</node>
</node>
<node CREATED="1576722345718" ID="ID_312245411" MODIFIED="1576722362549" TEXT="We try very hard to make uniform hash functions to minize the number of hash collisions">
<node CREATED="1576722364211" ID="ID_1200506814" MODIFIED="1576722424166" TEXT="A hash collision is when two objects, x, y hash to the same value (i.e. H(x) = H(y))."/>
</node>
<node CREATED="1576722434295" ID="ID_63759049" MODIFIED="1576722462536" TEXT="We are now able to answer a central question about the types of keys we are allowed to use in our hashtable:">
<node CREATED="1576722462528" ID="ID_1842837840" MODIFIED="1576722488238" TEXT="Q: What makes a key of type T hashable?">
<node CREATED="1576722503030" ID="ID_1267467075" MODIFIED="1576722583249" TEXT="A: Since we are going to use hash functions in the implementation of our hash table we need our hash functions to be deterministic. To enforce this behaviour, we demand that the keys used in our hashtable are immutable data types. Hence, if a key fof type T is immutable, and we have a hash function H(k) defined for all keys k of type T then we say a key of type T is hashable.">
<node CREATED="1576722609396" ID="ID_1217280733" MODIFIED="1576722620144" TEXT="keys are immutable - strings, integers">
<node CREATED="1576722621850" ID="ID_370951750" MODIFIED="1576722630456" TEXT="Not sets or lists"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1576722651007" ID="ID_523341002" MODIFIED="1576722656249" TEXT="How does a hash table work?">
<node CREATED="1576722659577" ID="ID_1534945728" MODIFIED="1576722679268" TEXT="Ideally we would like to have a very fast insertion, lookup and removal time for the data we are placing withing our hash table.">
<node CREATED="1576722744298" ID="ID_1247451831" MODIFIED="1576722754748" TEXT="Hash table is an array"/>
</node>
<node CREATED="1576722681238" ID="ID_505334372" MODIFIED="1576722705640" TEXT="Remarkably, we can achieve all this in O(1)* time using a hash function as a way to index into a hash table."/>
<node CREATED="1576722706750" ID="ID_574578431" MODIFIED="1576722726279" TEXT="* The constant time behaviour attributed to hash tables is only true if you have a good uniform hash function!"/>
<node CREATED="1576722787934" ID="ID_923768759" MODIFIED="1576722860059" TEXT="Think of the hash table on the right as an indexable block of memory (an array) and we can only access its entries using the value given to us by our hash function H(x)">
<node CREATED="1576723195754" ID="ID_791924647" MODIFIED="1576723243518" TEXT="Suppose we&apos;re inserting (integer, string) key-value pairs into teh table representing rankings of users to their usernames from an outline programming competition and we&apos;re using the hash function: H(x) = x^2 + 3 mod 10"/>
<node CREATED="1576723372256" ID="ID_1611902482" MODIFIED="1576723388217" TEXT="To lookup which user has rank r we simply compute H(f) and look inside the hashtable!"/>
</node>
<node CREATED="1576723400565" ID="ID_225952506" MODIFIED="1576723414922" TEXT="Q: What do we do if there is a hash collision?">
<node CREATED="1576723415408" ID="ID_1998476299" MODIFIED="1576723433414" TEXT="example: users with ranks 2 and 8 hash to the same value!!">
<node CREATED="1576723435059" ID="ID_477005514" MODIFIED="1576723454750" TEXT="H(2) = 2^2 + 3 mod 10 = 7 = 8^2 + 3 mod 10 = H(8)"/>
</node>
<node CREATED="1576723462070" ID="ID_1325438972" MODIFIED="1576723484930" TEXT="A: We use one of many hash collision resolution techniques to handle this, the two most popular ones are separate chaining and open addressing.">
<node CREATED="1576723500813" ID="ID_1405068280" MODIFIED="1576723553551" TEXT="Separate chaining deals with hash collisions by maintaining a data structure (usually a linked lis) to hold all the different values which hashed to a particular value."/>
<node CREATED="1576723554852" ID="ID_1904581245" MODIFIED="1576723596395" TEXT="Open addressing deals with hash collisions by finding place within the hash table for the object to go by offsetting it from the position to which it hashed to.">
<node CREATED="1576724661973" ID="ID_1478893207" MODIFIED="1576724665640" TEXT="Complexity:">
<node CREATED="1576724666247" ID="ID_1938104579" MODIFIED="1576724680568" TEXT="Insertion: Average - O(1)*, Wors - O(n)">
<node CREATED="1576724721965" ID="ID_172618407" MODIFIED="1576724745039" TEXT="* The constant time behavior attributed to hash tables is only true if you have agood uniform hash function!"/>
</node>
<node CREATED="1576724681231" ID="ID_1892088286" MODIFIED="1576724693824" TEXT="Removal: Average - O(1)*, Words - O(n)"/>
<node CREATED="1576724694561" ID="ID_1689831060" MODIFIED="1576724706600" TEXT="Search: Average - O(1)*, Worst - O(n)"/>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047845106" ID="ID_1637573432" MODIFIED="1567047851822" TEXT="Hash table separate chaining">
<node CREATED="1576726287665" ID="ID_1210949899" MODIFIED="1576726293186" TEXT="What is seperate chaining?">
<node CREATED="1576726293449" ID="ID_1062890330" MODIFIED="1576726331086" TEXT="Separate chaining is one of many strategiesto deal with hash collisions by maintaining a data strcuture (susually a linked list) to hold all the different values which hashed to a particular value.">
<node CREATED="1576726349314" ID="ID_70905475" MODIFIED="1576726355241" TEXT="Auxiliary data structure is used"/>
<node CREATED="1576726361987" ID="ID_1045936607" MODIFIED="1576726414027" TEXT="NOTE: The data structures used to cache the itemsused to cache the items which hashed to a particular value is not limited to a linked list. Some implemenatations use one or a mixture of: arrays, binary trees, self balancing trees and etc..."/>
</node>
<node CREATED="1576726547031" ID="ID_1776349136" MODIFIED="1576726556199" TEXT="Linked list separate chaining insertions">
<node CREATED="1576726557198" ID="ID_1720991584" MODIFIED="1576726578151" TEXT="Suppose we have a hash table that will store (name, age) key-value pairs and we wish to insert the following entries:">
<node CREATED="1576726837929" ID="ID_764009300" MODIFIED="1576726867602" TEXT="NOTE: Even if values are same, we store the key (name) value in the linked list block"/>
</node>
</node>
<node CREATED="1576726900360" ID="ID_366364213" MODIFIED="1576726904630" TEXT="Lookups">
<node CREATED="1576726907862" ID="ID_1406857671" MODIFIED="1576726930087" TEXT="To find the age of &quot;Ryan&quot; hash the key &quot;Ryan&quot; to obtain the value (index) 1. After this search teh 1 bucket for &quot;Ryan&quot;"/>
</node>
</node>
<node CREATED="1576727220861" ID="ID_1968344896" MODIFIED="1576727222951" TEXT="FAQs">
<node CREATED="1576727223153" ID="ID_852034882" MODIFIED="1576727249203" TEXT="Q: How do I maintain O(1) insertion and lookup time complexity once my HT gets really full and I have long linked list chains?">
<node CREATED="1576727250093" ID="ID_1297423091" MODIFIED="1576727284359" TEXT="A: Once the HT contains a lot of elements you should construct a new HT with a larger capacilty and rehash all the items inside the old HT and disperse them throughout the new HT ant different locations."/>
</node>
<node CREATED="1576727341227" ID="ID_1599242919" MODIFIED="1576727349145" TEXT="Q: How do I remove key-value pairs from my HT?">
<node CREATED="1576727349716" ID="ID_1202443782" MODIFIED="1576727391118" TEXT="A: Apply the same procedure as doing a lookup for a key, but this time instead of returning the value associated with the key remove the node in the linked list data structure."/>
</node>
<node CREATED="1576727401488" ID="ID_1609089780" MODIFIED="1576727418574" TEXT="Q: Can I use another data structure to model the bucket behaviour required for the sepaarate chaining method?">
<node CREATED="1576727421100" ID="ID_341353060" MODIFIED="1576727489445" TEXT="A: Of course! Common data structures used instead of a linked list include: arrays, binary trees, self balancing trees, etc... You can even go with a hybrid approach like Java&apos;s HashMap. However, note that some of these are much more memory intensive and complext to implement than a simple linked list which is why they may be less popular">
<node CREATED="1576727514527" ID="ID_438463014" MODIFIED="1576727534999" TEXT="Jaa switches t oa binary tree once the length gets to certain point"/>
<node CREATED="1576727558925" ID="ID_239823131" MODIFIED="1576727562723" TEXT="They might be faster"/>
</node>
</node>
</node>
</node>
<node CREATED="1567047852767" ID="ID_1781810660" MODIFIED="1567047861859" TEXT="Hash table separate chaining source code">
<node CREATED="1577334212789" ID="ID_1039092499" MODIFIED="1577369364567">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      <font size="1">class Entry &lt;K, V&gt; { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;int hash; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;K key; V value; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public Entry(K key, V value) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;this.key = key; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;this.value = value; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;this.hash = key.hashCode(); // cache to not recompute </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// We are not overriding the Object equals method </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// No casting is required with this method. </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public boolean equals(Entry &lt;K, V&gt; other) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (hash != other.hash) return false; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return key.equals(other.key); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;@Override public String toString() { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return key + &quot; =&gt; &quot; + value; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">@SuppressWarnings(&quot;unchecked&quot;) </font>
    </p>
    <p>
      <font size="1">public class HashTableSeparateChaining &lt;K, V&gt; implements Iterable &lt;K&gt; { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private static final int DEFAULT_CAPACITY = 3; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private static final double DEFAULT_LOAD_FACTOR = 0.75; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private double maxLoadFactor; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private int capacity, threshold, size = 0; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private LinkedList &lt;Entry&lt;K,V&gt;&gt; [] table; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public HashTableSeperateChaining () { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;this(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;}&#160; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public HashTableSeperateChaining (int capacity, double maxLoadFactor) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (capacity &lt; 0) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw new IllegalArgumentException(&quot;Illegal capacity&quot;); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (maxLoadFactor &lt;= 0 || Double.isNaN(maxLoadFactor) || Double.isInfinite(maxLoadFactor)) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw new IllegalArgumentException(&quot;Illegal maxLoadFactor&quot;); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;this.maxLoadFactor = maxLoadFactor; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;this.capacity = capacity; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;threshold = (int) (this.capacity * maxLoadFactor); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;table = new LinkedList[this.capacity]; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Returns the number of elements currently inside the hash-table </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public int size() { return size; } </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Returns true/false depending on whether the hash-table is empty </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public boolean isEmpty() { return size == 0; } </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Converts a hash value to an index. Essentially, this strips the </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// negative sign and places the hash value in the domain [0, capacity) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private int normalizeIndex(int keyHash) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return (keyHash &amp; 0x7FFFFFFF) % capacity; // strips negative sign </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Clears all the contents of the hash-table </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public void clear() { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Arrays.fill(table, null); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size = 0; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public boolean containsKey(K key) { return hasKey(key); } </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Returns true/false depending on whether a key is in the hash table </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public boolean hasKey(K key) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int bucketIndex = normalizeIndex(key.hashCode()); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return bucketSeekEntry(bucketIndex, key) != null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Insert, put and add all place a value in the hash-table </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public V put(K key, V value) { return insert(key, value); } </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public V add(K key, V value) { return insert(key, value); } </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public V insert(K key, V value) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (key == null) throw new IllegalArgumentException(&quot;Null key&quot;); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Entry &lt;K, V&gt; newEntry = new Entry&lt;&gt;(key, value); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int bucketIndex = normalizeIndex(newEntry.hash); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return bucketInsertEntry(bucketIndex, newEntry); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Gets a key's values from the map and returns the value. </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// NOTE: returns null if the value is null AND also returns </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// null if the key does not exists, so watch out.. </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public V get(K key) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (key == null) return null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int bucketIndex = normalizeIndex(key.hashCode()); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Entry &lt;K, V&gt; entry = bucketSeekEntry(bucketIndex, key); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (entry != null) return entry.value; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Removes a key from the map and returns the value. </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// NOTE: returns null if the value is null AND also returns </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// null if the key does not exists. </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public V remove(K key) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (key == null) return null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int bucketIndex = normalizeIndex(key.hashCode()); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return bucketRemoveEntry(bucketIndex, key); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Removes an entry from a given bucket if it exists </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private V bucketRemoveEntry(int bucketIndex, K key) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Entry &lt;K, V&gt; entry = bucketSeekEntry(bucketIndex, key); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (entry != null) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LinkedList &lt;Entry&lt;K, V&gt;&gt; links = table[bucketIndex]; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;links.remove(entry); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;--size; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return entry.value; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else return null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Inserts an entry in a given bucket only if the entry does not already </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// exist in the given bucket, but if it does then update the entry value </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private V bucketInsertEntry(int bucketIndex, Entry &lt;K, V&gt; entry) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LinkedList &lt;Entry&lt;K, V&gt;&gt; bucket = table[bucketIndex]; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (bucket == null) table[bucketIndex] = bucket = new LinkedList&lt;&gt;(); </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Entry &lt;K, V&gt; existentEntry = bucketSeekEntry(bucketIndex, entry.key); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (existentEntry == null) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bucket.add(entry); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (++size &gt; threshold) resizeTable(); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return null; // Use null to indicate that there was no previous entry </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} else { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;V oldVal = existentEntry.value; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;existentEntry.value = entry.value; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return oldVal; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Finds and returns a particular entry in a given bucket if it exists, returns null otherwise </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private Entry &lt;K, V&gt; bucketSeekEntry(int bucketIndex, K key) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (key == null) return null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LinkedList &lt;Entry&lt;K, V&gt;&gt; bucket = table[bucketIndex]; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (bucket == null) return null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (Entry &lt;K, V&gt; entry : bucket) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (entry.key.equals(key)) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return entry; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Resizes the internal table holding buckets of entries </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;private void resizeTable() { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;capacity *= 2; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;threshold = (int) (capacity * maxLoadFactor); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LinkedList &lt;Entry&lt;K,V&gt;&gt; [] newTable = new LinkedList[capacity]; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (int i = 0; i &lt; table.length; i++) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (table[i] != null) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (Entry &lt;K, V&gt; entry : table[i]) { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int bucketIndex = normalizeIndex(entry.hash); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LinkedList&lt;Entry&lt;K,V&gt;&gt; bucket = newTable[bucketIndex]; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (bucket == null) newTable[bucketIndex] = bucket = new LinkedList&lt;&gt;(); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bucket.add(entry); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// Avoid memory leak. Help the GC </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;table[i].clear(); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;table[i] = null; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}&#160;&#160;&#160; </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;table = newTable; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Returns the list of keys found within the hash table </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public List &lt;K&gt; keys() { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;List &lt;K&gt; keys = new ArrayList&lt;&gt;(size()); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (LinkedList&lt;Entry&lt;K,V&gt;&gt; bucket : table) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (bucket != null) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (Entry &lt;K,V&gt; entry : bucket) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;keys.add(entry.key); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;return keys; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;// Returns the list of values found within the hash table </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;public List &lt;V&gt; values() { </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;List &lt;V&gt; values = new ArrayList&lt;&gt;(size()); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (LinkedList&lt;Entry&lt;K,V&gt;&gt; bucket : table) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (bucket != null) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (Entry &lt;K,V&gt; entry : bucket) </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;values.add(entry.value); </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return values; </font>
    </p>
    <p>
      <font size="1">&#160;&#160;&#160;&#160;} </font>
    </p>
    <p>
      <font size="1">} </font>
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node CREATED="1567047863123" ID="ID_1180079256" MODIFIED="1567047869247" TEXT="Hash table open addressing">
<node CREATED="1577369532976" ID="ID_1689117443" MODIFIED="1577369540468" TEXT="Collision resolution technique"/>
<node CREATED="1577369543428" ID="ID_200938945" MODIFIED="1577369547331" TEXT="Open addressing basics">
<node CREATED="1577369547601" ID="ID_1618933428" MODIFIED="1577369562797" TEXT="The goal of the Hash Table (HT) is to construct a mapping from keys to values."/>
<node CREATED="1577369565898" ID="ID_1462552710" MODIFIED="1577369580451" TEXT="Keys must be hashable and we need a hash function that converts keys to whole numbers."/>
<node CREATED="1577369580828" ID="ID_1706198356" MODIFIED="1577369598220" TEXT="We use the hash function defined on our key set to index into an array (the hash table)."/>
<node CREATED="1577369598691" ID="ID_1870903960" MODIFIED="1577369643429" TEXT="Hash functions are not perfect, therefore sometimes two keys k1, k2 (k1 != k2) hash to the same value. When this happens we have a hash collision (i.e H(k1 = H(k2))"/>
<node CREATED="1577369644277" ID="ID_1732474554" MODIFIED="1577369650757" TEXT="Open addressing is a way to solve this issue.">
<node CREATED="1577369725675" ID="ID_1006939397" MODIFIED="1577369729212" TEXT="Open addressing basics">
<node CREATED="1577369729829" ID="ID_1357789143" MODIFIED="1577369767421" TEXT="When using open addressing as a collision resolution technique the key-value pairs are stored in teh table (array) itself as opposed to a data structure like in separate chaining."/>
<node CREATED="1577369769214" ID="ID_1933827972" MODIFIED="1577369789661" TEXT="This means we need to care a great deal about the size of our hash table and how many elements are currently in the table">
<node CREATED="1577369790630" ID="ID_783717030" MODIFIED="1577369799174" TEXT="Load factor = items in table / size of table"/>
<node CREATED="1577369848109" ID="ID_78644049" MODIFIED="1577369853668" TEXT="or else difficult to find slot"/>
</node>
</node>
</node>
<node CREATED="1577369884965" ID="ID_245954382" MODIFIED="1577369926941" TEXT="The O(1) constant time behaviour attributed to hash tables ssumes the load factor (alpha) is kept below a certain fixed value. This means once alpha &gt; threshold we need to grow the table size (ideally exponentially, e.g double).">
<node CREATED="1577369948941" ID="ID_1421341182" MODIFIED="1577369959736" TEXT="It may get exponentially bad after certain threshold"/>
</node>
<node CREATED="1577369975963" ID="ID_974261891" MODIFIED="1577369981224" TEXT="Open addressing main idea">
<node CREATED="1577369983373" ID="ID_433586555" MODIFIED="1577370020144" TEXT="When we want to insert a key-value pair (k, v) into the hash table we hash the key and obtain an original position for where this key-value pair belongs, i.e H(k)"/>
<node CREATED="1577370022101" ID="ID_1145833824" MODIFIED="1577370058985" TEXT="If the position our key hashed to is occupied we try another position in the hash table by offsetting the current position subject o a probing sequence P(x). We keep doing this until an unoccupied slot is found."/>
<node CREATED="1577370120313" ID="ID_932454091" MODIFIED="1577370137628" TEXT="There are an infinite amount of probing sequences you can come up with, here are a few:">
<node CREATED="1577370138724" ID="ID_750593367" MODIFIED="1577370157299" TEXT="Linear probing">
<node CREATED="1577370157779" ID="ID_922155410" MODIFIED="1577370169217" TEXT="P(x) = ax + b where a, b are constants"/>
</node>
<node CREATED="1577370171738" ID="ID_1917168744" MODIFIED="1577370176061" TEXT="Quadratic probing">
<node CREATED="1577370176282" ID="ID_44258301" MODIFIED="1577370194942" TEXT="P(x) = ax^2 + bx + c where a, b, c are constants"/>
</node>
<node CREATED="1577370196206" ID="ID_492274658" MODIFIED="1577370199220" TEXT="Double hashing">
<node CREATED="1577370199525" ID="ID_41924921" MODIFIED="1577370220113" TEXT="P(k,x) = x*H2(k), where H2(k) is a secondary hash function"/>
</node>
<node CREATED="1577370221605" ID="ID_1414408699" MODIFIED="1577370230446" TEXT="Pseudo random number generator:">
<node CREATED="1577370230815" ID="ID_344675924" MODIFIED="1577370264202" TEXT="P(k,x) = x * RNG(H(k), x), where RNG is a random number generator function seeded with H(k)">
<node CREATED="1577370342147" ID="ID_460257500" MODIFIED="1577370355235" TEXT="sead is H(k) which is deterministic (same always)">
<node CREATED="1577370377456" ID="ID_1325730476" MODIFIED="1577370383894" TEXT="x increments by 1 each time"/>
</node>
</node>
</node>
</node>
<node CREATED="1577370396111" ID="ID_668632316" MODIFIED="1577370409027" TEXT="General insertion method for open addressing on a table of size N goes as follows:">
<node CREATED="1577370413508" ID="ID_324538868" MODIFIED="1577370505615">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      x := 1
    </p>
    <p>
      keyHash := H(k)
    </p>
    <p>
      index := keyHash
    </p>
    <p>
      
    </p>
    <p>
      while table[index] != null:
    </p>
    <p>
      &#160;&#160;&#160;&#160;index = (keyHash + P(k,x)) mod N
    </p>
    <p>
      &#160;&#160;&#160;&#160;x = x + 1
    </p>
    <p>
      
    </p>
    <p>
      insert (k,v) at table[index]
    </p>
    <p>
      
    </p>
    <p>
      Where H(k) is the hash for the key k and P(k,x) is the probing function
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node CREATED="1577370613045" ID="ID_372683697" MODIFIED="1577370616078" TEXT="Chaos with cycles">
<node CREATED="1577370616406" ID="ID_785800868" MODIFIED="1577370635366" TEXT="Most randomly selected probing sequences modulo N will produce a cycle shorter than the table size."/>
<node CREATED="1577370636695" ID="ID_468980738" MODIFIED="1577370661647" TEXT="This becomes problamatic when you are trying to insert a key-value pair and all the buckets on the cycle are occupied because you will get stuck in an infinite loop!">
<node CREATED="1577370714038" ID="ID_48188437" MODIFIED="1577370734183" TEXT="Suppose the sequence produces only 3 slots and cycles through them infinitely">
<node CREATED="1577370748803" ID="ID_582834116" MODIFIED="1577370750674" TEXT="Example:">
<node CREATED="1577370750864" ID="ID_214027381" MODIFIED="1577370791996" TEXT="k1,v1, null, null, k2,v2, k3,v3,k4,v4, null, null, k5,v5, null, k6,v6, null">
<node CREATED="1577370793485" ID="ID_115437890" MODIFIED="1577370807477" TEXT="Assume the probing sequence used is P(x) = 4x"/>
<node CREATED="1577370807837" ID="ID_1577758174" MODIFIED="1577370823814" TEXT="Now suppose we want to insert (k,v) into the table and H(k) = 8">
<node CREATED="1577619298033" ID="ID_398640541" MODIFIED="1577619408682" TEXT="index = H(k) = 8 + 0 mode 12 = 8"/>
<node CREATED="1577619310186" ID="ID_1092679344" MODIFIED="1577619372033" TEXT="index = H(k) + P(1) = 8 + 4 mod 12 = 0"/>
<node CREATED="1577619327318" ID="ID_427905433" MODIFIED="1577619364816" TEXT="index = H(k) + P(2) = 8 + 8 mod 12 = 4"/>
<node CREATED="1577619382448" ID="ID_821101256" MODIFIED="1577619402104" TEXT="index = H(k) + P(3) = 8 + 12 mod 12 = 8"/>
<node CREATED="1577619410482" ID="ID_1492200526" MODIFIED="1577619412274" TEXT="..."/>
</node>
<node CREATED="1577619441330" ID="ID_1927049410" MODIFIED="1577619451265" TEXT="We have a cycle even though there are empty slots"/>
</node>
</node>
<node CREATED="1577619458384" ID="ID_1105828211" MODIFIED="1577619480425" TEXT="Q: So that&apos;s concerning, how do we handle probing functions which produce cycles shorter than the table size?">
<node CREATED="1577619484985" ID="ID_1834393274" MODIFIED="1577619533375" TEXT="A: In general the concesnus is that we don&apos;t handle this issue, instead we avoid it altogether by restricting our domain of probing functions to those which produce a cycle of exactly length N*">
<node CREATED="1577619536883" ID="ID_1433164446" MODIFIED="1577619556246" TEXT="* There are a few exceptions with special proprties that can produce shorter cycles."/>
</node>
</node>
<node CREATED="1577619616414" ID="ID_383019877" MODIFIED="1577619620653" TEXT="Chaos with cycles">
<node CREATED="1577619624190" ID="ID_1674799779" MODIFIED="1577619667581" TEXT="Techniques such as linear probing, quadratic probing and double hashing are all subject to the issue of causing cycles which is why the probing functions used with these methods are very specific. This is a large topic that will be the focus of the next few vidoes."/>
<node CREATED="1577619669391" ID="ID_1618509427" MODIFIED="1577619713511" TEXT="Notice that open addressing is very sensitive to the hashing function and probing function used. This is not something you have to worry about (as much) if you are using separate chaining as a collision resolution method."/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047870330" ID="ID_146250376" MODIFIED="1567047875833" TEXT="Hash table linear probing">
<node CREATED="1577619920151" ID="ID_1851249096" MODIFIED="1577619926308" TEXT="Open addressing main idea">
<node CREATED="1577619926872" ID="ID_1147539272" MODIFIED="1577620008347">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      General insertion method for open addressing on a table of size N goes as follows:
    </p>
    <p>
      
    </p>
    <p>
      x := 1
    </p>
    <p>
      keyHash := H(k)
    </p>
    <p>
      index := keyHash
    </p>
    <p>
      
    </p>
    <p>
      while table[index] != null:
    </p>
    <p>
      &#160;&#160;&#160;&#160;index = (keyHash + P(k,x)) mod N
    </p>
    <p>
      &#160;&#160;&#160;&#160;x = x + 1
    </p>
    <p>
      
    </p>
    <p>
      insert (k, v) at table[index]
    </p>
    <p>
      
    </p>
    <p>
      where H(k) is the hash for the key k and P(k,x) is the probing function
    </p>
  </body>
</html></richcontent>
<node CREATED="1577620034317" ID="ID_1379463749" MODIFIED="1577620042229" TEXT="What is linear probing (LP)?">
<node CREATED="1577620043130" ID="ID_1332539606" MODIFIED="1577620061852" TEXT="LP is a probing method which probes according to a lnear formula, specifically:">
<node CREATED="1577620062411" ID="ID_1116627164" MODIFIED="1577620099102" TEXT="P(x) = ax + b where a (!=0), be are constants (Note: The constant b is obsolete, do you know why?)">
<node CREATED="1577620129162" ID="ID_1934365427" MODIFIED="1577620158588" TEXT="However, as we previously saw not all linear functions are viable because they are unable to produce a cycle of order N. We will need some way to handle this."/>
</node>
</node>
</node>
<node CREATED="1577620181008" ID="ID_395596916" MODIFIED="1577620249775" TEXT="If our linear function is: P(x) = 3x, H(k) = 4, and table size is nine (N = 9) we end up with the following cycle occurring:g:">
<node CREATED="1577620250046" ID="ID_1916993484" MODIFIED="1577620258598" TEXT="H(k) + P(0) mod N = 4"/>
<node CREATED="1577620258822" ID="ID_1092062" MODIFIED="1577620270234" TEXT="H(k) + P(1) mod N = 7"/>
<node CREATED="1577620270473" ID="ID_55739188" MODIFIED="1577620284757" TEXT="H(k) + P(2) mod N = 1"/>
<node CREATED="1577620285094" ID="ID_1912421457" MODIFIED="1577620297886" TEXT="H(k) + P(3) mod N = 4"/>
<node CREATED="1577620298790" ID="ID_279494917" MODIFIED="1577620299694" TEXT="..."/>
</node>
<node CREATED="1577620337789" ID="ID_148960283" MODIFIED="1577620360735" TEXT="The cycle {4,7,1} makes it impossible to reach buckets {0,2,3,5,6,8}!">
<node CREATED="1577620363639" ID="ID_1583601574" MODIFIED="1577620379047" TEXT="Causing infinite loop in our hash table if all the buckets 4, 7, and 1 were already occupied!"/>
</node>
<node CREATED="1577620418001" ID="ID_1516221096" MODIFIED="1577620436397" TEXT="Q: Which value(s) of the constant a in P(x) = ax produce a full cycle module N??">
<node CREATED="1577620437316" ID="ID_1543377192" MODIFIED="1577620502262" TEXT="A: This happens when a and N are relatively prime. Two numbers are relatively prime if their Greatest Common Denominator (GCD) is equal to one. Hence, when GCD(a,N) = 1 the probing function P(x) be able to generate a complete cycle and we will always be able to find an empty bucket!"/>
</node>
<node CREATED="1577620632341" ID="ID_266375603" MODIFIED="1577620657755" TEXT="Suppose we have an originally empty hash table ans we want to insert some (ki,vi) pairs with LP and we selected our hash table to have:">
<node CREATED="1577620658138" ID="ID_34004819" MODIFIED="1577620671115" TEXT="Probing function: P(x) = 6x"/>
<node CREATED="1577620671356" ID="ID_1393257194" MODIFIED="1577620678034" TEXT="Fixed table size: N = 8"/>
<node CREATED="1577620678963" ID="ID_1677260361" MODIFIED="1577620686891" TEXT="Max load factor: alpha = 0.667"/>
<node CREATED="1577620687668" ID="ID_274216484" MODIFIED="1577620696802" TEXT="Threshold before resize = N * alpha = 6">
<node CREATED="1577620749531" ID="ID_1432589682" MODIFIED="1577620762902" TEXT="GCD(6, 9) = 3 and not 1">
<node CREATED="1577620952802" ID="ID_1036035522" MODIFIED="1577620982944" TEXT="Most likely to cause cycle"/>
</node>
</node>
</node>
<node CREATED="1577621010764" ID="ID_1068529528" MODIFIED="1577621031654" TEXT="A common choice for P(x) is P(x) = 1x since GCD(N, 1) = 1 no matter the choice of N (table size)">
<node CREATED="1577621468823" ID="ID_1541073778" MODIFIED="1577621503175" TEXT="Suppose we have an originally empty hash table and we want to insert some (ki,vi) pairs with LP and we welected our hash table to have:">
<node CREATED="1577621503749" ID="ID_1776369745" MODIFIED="1577621563494">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Probing function: P(x) = 5x
    </p>
    <p>
      Fixed table size: N = 12
    </p>
    <p>
      Max load factor: @ = 0.35
    </p>
    <p>
      Threshold before resize = N * alpha = 4
    </p>
    <p>
      
    </p>
    <p>
      GCD(12, 5) = 1 so no cycle should occur!
    </p>
  </body>
</html></richcontent>
<node CREATED="1577621576440" ID="ID_1662673749" MODIFIED="1577621592784" TEXT="H(k1) + P(0) mod 12 = 10"/>
<node CREATED="1577621596789" ID="ID_946609011" MODIFIED="1577621612927" TEXT="H(k2) + P(0) mod 12 = 8"/>
<node CREATED="1577621613182" ID="ID_1753935856" MODIFIED="1577621624074" TEXT="H(k3) + P(1) mod 12 = 3"/>
<node CREATED="1577621626329" ID="ID_1341414478" MODIFIED="1577621651265" TEXT="H(k4) + P(3) mod 12 = 1"/>
<node CREATED="1577621669430" ID="ID_1899446043" MODIFIED="1577621678655" TEXT="threshold = 4">
<node CREATED="1577621681525" ID="ID_380790446" MODIFIED="1577621685989" TEXT="Resizing the table">
<node CREATED="1577621695874" ID="ID_1968764159" MODIFIED="1577621753722" TEXT="Before we insert the next (ki,vi) pair, notice that we have reached the threshold value, so we need to grow the table. Usually this is done in some exponential fashion such as doubling the table size,Whatever you do make sure GCD(N,a) = 1 still holds.">
<node CREATED="1577621848015" ID="ID_771616597" MODIFIED="1577621878275" TEXT="After doubling N = 24 alpha is constant so it&apos;s still 0.35 New threshold value = N * alpha = 8, The probing function P(x) does not change.">
<node CREATED="1577621919175" ID="ID_823893828" MODIFIED="1577621947371" TEXT="Upon allocating memory for a new table we need to insert the contents of the old table into the new table.">
<node CREATED="1577621978457" ID="ID_295068800" MODIFIED="1577621989693" TEXT="scan all positions and re-calculate index and copy"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1577622072499" ID="ID_769535602" MODIFIED="1577622097356" TEXT="Q: Sweet, I know how insertion works, now how do I remove key-value pairs from the hash table using open addressing?">
<node CREATED="1577622103131" ID="ID_1475346986" MODIFIED="1577622116771" TEXT="A: This topic by itself mertis its own video (link in the description)."/>
</node>
</node>
</node>
<node CREATED="1567047877084" ID="ID_1344116679" MODIFIED="1567047883639" TEXT="Hash table quadratic probing">
<node CREATED="1577633773588" ID="ID_1117252357" MODIFIED="1577633779864" TEXT="What is quadratic probing?">
<node CREATED="1577633780979" ID="ID_1930003366" MODIFIED="1577633797071" TEXT="QP is a probing method which probes according to a quadratic formula, specifically:">
<node CREATED="1577633797512" ID="ID_372367502" MODIFIED="1577633835920" TEXT="P(x) = ax^2 + bx + c where a,b,c are constants and a != 0 (otherwise we have linear probing) (Note: The constant c is obsolete, do you know why?)">
<node CREATED="1577635255432" ID="ID_1590497890" MODIFIED="1577635286822" TEXT="However, as we previously saw not all quadratic functions are viable because they are unable to produce a cycle of order N. We will need some way to handle this."/>
</node>
</node>
<node CREATED="1577635922948" ID="ID_706060464" MODIFIED="1577635927247" TEXT="Chaos with Cycles">
<node CREATED="1577635928335" ID="ID_1814808605" MODIFIED="1577635979306" TEXT="Randomly selected QP functions have the issue that they easily produce short cycles. For example, if P(x) = 2x^2 + 2, H(k) = 4, and table size is nine (N  9) we end up with the following cycle occurring:">
<node CREATED="1577635981280" ID="ID_1961313944" MODIFIED="1577635990408" TEXT="H(k) + P(0) mod N = 4"/>
<node CREATED="1577636000427" ID="ID_1022512573" MODIFIED="1577636008442" TEXT="H(k) + P(1) mod N = 7"/>
<node CREATED="1577636009870" ID="ID_1697740604" MODIFIED="1577636018130" TEXT="H(k) + P(2) mod N = 4"/>
<node CREATED="1577636018880" ID="ID_1385709185" MODIFIED="1577636027322" TEXT="H(k) + P(3) mod N = 7"/>
<node CREATED="1577636027897" ID="ID_1063380178" MODIFIED="1577636035051" TEXT="H(k) + P(4) mod N = 4"/>
<node CREATED="1577636035428" ID="ID_1191560945" MODIFIED="1577636042715" TEXT="H(k) + P(5) mod N = 7"/>
</node>
<node CREATED="1577636046489" ID="ID_1436287773" MODIFIED="1577636073427" TEXT="The cycle {4,7} makes it impossible to reach buckets {0,1,2,3,5,6,8}!"/>
<node CREATED="1577636074362" ID="ID_77422493" MODIFIED="1577636091899" TEXT="This would cause an infinite loop in our hash table if the buckets 4 and 7 were already occupied!">
<node CREATED="1577805164590" ID="ID_1585309245" MODIFIED="1577805189405" TEXT="Q: So how do we pick a probing function we can work with?">
<node CREATED="1577805193924" ID="ID_1455074623" MODIFIED="1577805223081" TEXT="merous ways, but thA: There are numerous ways but three of the most popular approaches are:">
<node CREATED="1577805223282" ID="ID_244432597" MODIFIED="1577805241191" TEXT="Let P(x) = x^2, keep the table size a prime number &gt; 3 and also keep alpha &lt;= 1/2"/>
<node CREATED="1577805243588" ID="ID_1067704977" MODIFIED="1577805260872" TEXT="Let P(x) = (x^2 + x) / 2 and keep the table size a power of two">
<node CREATED="1577805369449" ID="ID_385033137" MODIFIED="1577805377903" TEXT="Let&apos;s see an example">
<node CREATED="1577805397684" ID="ID_1545194148" MODIFIED="1577805424711" TEXT="Suppose we have an originall empty hash table ans we want to insert some (ki, vi) pairs with QP and we selected our hash table to have:">
<node CREATED="1577805429249" ID="ID_708331423" MODIFIED="1577805442197" TEXT="Probing function: P(x) = (x^2 + x) / 2"/>
<node CREATED="1577805443827" ID="ID_552971233" MODIFIED="1577805457657" TEXT="Table size: N = 2^3 = 8 (power of two)"/>
<node CREATED="1577805458301" ID="ID_349573618" MODIFIED="1577805467455" TEXT="Max load factor: alpha = 0.4"/>
<node CREATED="1577805468191" ID="ID_938194267" MODIFIED="1577805491734" TEXT="Threshold before resize = N * alpha = 3"/>
</node>
</node>
</node>
<node CREATED="1577805261156" ID="ID_65098880" MODIFIED="1577805287294" TEXT="Let P(x) = (-1^x)*x^2 and keep the table size a prime N where N = 3 mod 4"/>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047884522" ID="ID_1596198472" MODIFIED="1567047889979" TEXT="Hash table double hashing">
<node CREATED="1577805983641" ID="ID_1239811474" MODIFIED="1577806080229" TEXT="DH is a probing method which probes according to a constant multiple of another hash function, specifically:">
<node CREATED="1577806081000" ID="ID_1237282159" MODIFIED="1577806107772" TEXT="P(k,x) = x*H2(k), where H2(k) is a second hash funcion">
<node CREATED="1577807077051" ID="ID_909830346" MODIFIED="1577807086362" TEXT="H2(k) must hash the same type of keys as H1(k)">
<node CREATED="1577807087755" ID="ID_1951383631" MODIFIED="1577807105386" TEXT="NOTE: Notice that doubling hashing reduces to linear probing (except that the constant is unknown until runtime)">
<node CREATED="1577807106987" ID="ID_1087890379" MODIFIED="1577807114188" TEXT="constant is dynamically computed"/>
</node>
</node>
</node>
<node CREATED="1577807129989" ID="ID_809595202" MODIFIED="1577807133396" TEXT="Chaos with cycles">
<node CREATED="1577807138396" ID="ID_263386164" MODIFIED="1577807182422" TEXT="Since DH reduces to linear probing at runtime we may end up with a linear prbing function such as: P9x) = 3x, H1(k) = 4, and table size is nine (N= 9) in which case we end up with the following cycle occurring:">
<node CREATED="1577807184185" ID="ID_111127273" MODIFIED="1577807193324" TEXT="H(k) + P(0) mod N = 4"/>
<node CREATED="1577807193565" ID="ID_49535707" MODIFIED="1577807200828" TEXT="H(k) + P(1) mod N = 7"/>
<node CREATED="1577807201061" ID="ID_1125610781" MODIFIED="1577807206892" TEXT="H(k) + P(2) mod N = 1"/>
<node CREATED="1577807207130" ID="ID_945380953" MODIFIED="1577807213405" TEXT="H(k) + P(3) mod N = 4"/>
<node CREATED="1577807213987" ID="ID_725612052" MODIFIED="1577807214982" TEXT="...">
<node CREATED="1577807233747" ID="ID_1714598309" MODIFIED="1577807266861" TEXT="The cycle {4,7,1} makes it impossible to reach buckets {0,2,3,5,6,8}!"/>
<node CREATED="1577807267936" ID="ID_1685937339" MODIFIED="1577807292675" TEXT="This would cause an infinite loop in our hash table if all the buckets 4, 7, and 1 were already occupied!"/>
<node CREATED="1577807305408" ID="ID_1614239722" MODIFIED="1577807305408" TEXT=""/>
</node>
<node CREATED="1577807323478" ID="ID_864436125" MODIFIED="1577807340955" TEXT="To fix the issue of cycles pick the table size to be a prime number and also computer the value of delta">
<node CREATED="1577807341320" ID="ID_711140232" MODIFIED="1577810307617" TEXT="delta = H2(k) mod N">
<node CREATED="1577811347074" ID="ID_256574576" MODIFIED="1577811368125" TEXT="If delta = 0 then we are guaranteed to be stuck in a cycle, so when this happens set delta = 1">
<node CREATED="1577811371004" ID="ID_442988557" MODIFIED="1577811436098" TEXT="Notice that 1 &lt;= delta &lt; N and GCD(delta, N) = 1 since N is prime. Hence, with these conditions we know that module N the sequence: H1(k), H1(k) + 1.delta, H1(k) + 2.delta, H1(k) + 3.delta, ... is certain to have order N"/>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1577813284991" ID="ID_1283118554" MODIFIED="1577813291678" TEXT="Constructing H2(k)">
<node CREATED="1577813292172" ID="ID_1582423647" MODIFIED="1577813297591" TEXT="Suppose the key k has type T"/>
<node CREATED="1577813304284" ID="ID_1616026116" MODIFIED="1577813331572" TEXT="Whenever we want to use double hashing as a collision resolution method we need to fabricate a new function H2(k) that knows how to hash keys of type T."/>
<node CREATED="1577813332469" ID="ID_113559667" MODIFIED="1577813363550" TEXT="It would be nice to have a systematic way to be able to effectively produce a new hash function every time we need one, right?"/>
<node CREATED="1577813371867" ID="ID_171577377" MODIFIED="1577813406463" TEXT="The keys we need to hash are always composed of the same fundamental building blocks. In particular: integers, strings, real numbers, fixed length vectors, etc..."/>
<node CREATED="1577813430143" ID="ID_1514828790" MODIFIED="1577813466023" TEXT="There are many well known high quality hash functions for these fundamental data types. hence, we can use and combine them to contruct our function H2(k)."/>
<node CREATED="1577813469650" ID="ID_513114044" MODIFIED="1577813498805" TEXT="Frequently the hash functions selected to compose H2(k) are picked from a pool of hash functions called unversal hash functions which generally operate on one fundamental data type."/>
</node>
<node CREATED="1577814522335" ID="ID_774886785" MODIFIED="1577814527558" TEXT="Inserting with DH">
<node CREATED="1577814528102" ID="ID_1492862140" MODIFIED="1577814559062" TEXT="Suppose we have an originally empty hash table and we want to insert some (ki,vi) pairs with DH and we selected our hash table to have:">
<node CREATED="1577814559333" ID="ID_1512930342" MODIFIED="1577814575029" TEXT="Probing function: P(x) = x*H2(k)"/>
<node CREATED="1577814575405" ID="ID_1398982206" MODIFIED="1577814582949" TEXT="Table size: N = 7 (a prime number)"/>
<node CREATED="1577814583701" ID="ID_613893496" MODIFIED="1577814591466" TEXT="Max load factor: alpha = 0.75"/>
<node CREATED="1577814591679" ID="ID_790795323" MODIFIED="1577814600069" TEXT="Threshold before resize = N * alpha = 5">
<node CREATED="1577814896859" ID="ID_528503729" MODIFIED="1577814941560" TEXT="Double table size to re-size and choose the next prime number"/>
</node>
</node>
</node>
</node>
<node CREATED="1567047890930" ID="ID_422156043" MODIFIED="1567047899043" TEXT="Hash table removing key-value pairs">
<node CREATED="1577815330378" ID="ID_1892933450" MODIFIED="1577815361442" TEXT="Suppose we have an empty hash table and we&apos;re using liner probing with P(x) = x as our probing function.">
<node CREATED="1577815424301" ID="ID_1788062374" MODIFIED="1577815434662" TEXT="Operations:">
<node CREATED="1577815435543" ID="ID_371740793" MODIFIED="1577815439735" TEXT="insert(k1,v1)"/>
<node CREATED="1577815440195" ID="ID_1630433242" MODIFIED="1577815443786" TEXT="insert(k2,v2)"/>
<node CREATED="1577815444192" ID="ID_813191230" MODIFIED="1577815448742" TEXT="insert(k3,v3)"/>
<node CREATED="1577815449148" ID="ID_250761687" MODIFIED="1577815451879" TEXT="remove(k2)"/>
<node CREATED="1577815452439" ID="ID_1232305860" MODIFIED="1577815456103" TEXT="getValue(k3)"/>
</node>
<node CREATED="1577815464506" ID="ID_702618996" MODIFIED="1577815475203" TEXT="Let H(k1) = H(k2) = H(k3) = 1">
<node CREATED="1577815486741" ID="ID_79902001" MODIFIED="1577815489397" TEXT="Hash collision">
<node CREATED="1577815499262" ID="ID_1006095926" MODIFIED="1577815506636" TEXT="1 -&gt; k1,v1"/>
<node CREATED="1577815506923" ID="ID_248653207" MODIFIED="1577815512355" TEXT="2 -&gt; k2,v2"/>
<node CREATED="1577815512738" ID="ID_595324504" MODIFIED="1577815521609" TEXT="3 -&gt; k3,v3"/>
</node>
<node CREATED="1577815538991" ID="ID_125977731" MODIFIED="1577815542376" TEXT="Naive removal">
<node CREATED="1577815546210" ID="ID_717474599" MODIFIED="1577815553942" TEXT="2 -&gt; k2,v2">
<node CREATED="1577815554268" ID="ID_374804421" MODIFIED="1577815555952" TEXT="Remove it"/>
</node>
</node>
<node CREATED="1577815586718" ID="ID_778554536" MODIFIED="1577815590821" TEXT="getValue(k3)">
<node CREATED="1577815591198" ID="ID_1670938520" MODIFIED="1577815631631" TEXT="The value in the bucket at index 2 is null so we must conclude that the key k3 does not exist in the hash table otherwise we would have found it before reaching a null position!">
<node CREATED="1577815690831" ID="ID_155637504" MODIFIED="1577815710121" TEXT="However, the key k3 clearly exists in our table! Hence, the naive removing method doesn&apos;t work"/>
</node>
<node CREATED="1577815736768" ID="ID_1751847673" MODIFIED="1577815773883" TEXT="Soluiotion: place a unique marker called a tomstone instead of null to indicate that a (k,v) pair has been deleted and that the bucket should be skipped during a search.">
<node CREATED="1577815792864" ID="ID_1756910892" MODIFIED="1577815807651" TEXT="Search will continue if tomstone is encountered"/>
</node>
</node>
</node>
<node CREATED="1577815854821" ID="ID_1646066875" MODIFIED="1577815874924" TEXT="Q: I have a lot of tomstones cluttering my HT how do I get rid of them?">
<node CREATED="1577815926264" ID="ID_1089459859" MODIFIED="1577815976568" TEXT="A: Tomstones count as filled slots in the HT so they increase the load factor and will be removed when the table is resized. Additionally, when inserting a new (k,v) pair you can replace buckets with tomstones with the new key-value pair.">
<node CREATED="1577816036172" ID="ID_1866896141" MODIFIED="1577816075430" TEXT="Suppose we have the following HT with the quadratic prbing function P9x) = (x^2 + x)/2. Let&apos;s see how to delete tombstones while doing a lookup."/>
<node CREATED="1577816092378" ID="ID_1632180662" MODIFIED="1577816101770" TEXT="Recall that P(x) = (x^2 + x)/2">
<node CREATED="1577816102072" ID="ID_1189118496" MODIFIED="1577816121747" TEXT="Suppose we want to find the value of k7 inside the HT and H(K7) = 5."/>
<node CREATED="1577816124107" ID="ID_194506510" MODIFIED="1577816153032" TEXT="Position 6 is the first tombstone we encounter, so store this position for later.">
<node CREATED="1577816210150" ID="ID_347760179" MODIFIED="1577816252897" TEXT="Optimization: re-locate the found element to the first tomstone position">
<node CREATED="1577816254654" ID="ID_608619853" MODIFIED="1577816280207" TEXT="We found the key k7 and its associated value v7, but we don&apos;t want to probe an additional four times to find k7 every time we do a lookup for its value."/>
<node CREATED="1577816280607" ID="ID_1853797160" MODIFIED="1577816705942" TEXT="An optimization we can do it replace the earliest tomstone encountered with teh value we did a lookup for. The next time we lookup the key it &apos;ll be found much faster! We call this lazy deletion"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047903541" ID="ID_1761414486" MODIFIED="1567047910266" TEXT="Hash table open addressing source code"/>
</node>
<node CREATED="1567047916017" ID="ID_1895167146" MODIFIED="1567047925223" POSITION="left" TEXT="Fenwick tree/ Binary indexed tree">
<node CREATED="1567047926501" ID="ID_1669705925" MODIFIED="1567047932949" TEXT="Fenwick tree range queries">
<node CREATED="1577845856279" ID="ID_1867988588" MODIFIED="1577845866522" TEXT="Also called Binary Indexed Tree"/>
<node CREATED="1577845868541" ID="ID_202260371" MODIFIED="1577845871849" TEXT="Outline">
<node CREATED="1577845875709" ID="ID_357522876" MODIFIED="1577845887706" TEXT="Discussion &amp; Examples">
<node CREATED="1577845897160" ID="ID_1092701357" MODIFIED="1577845902522" TEXT="Data structure motivation"/>
<node CREATED="1577845902730" ID="ID_37552349" MODIFIED="1577845910610" TEXT="What is a Fenwick tree?"/>
<node CREATED="1577845911089" ID="ID_1924714467" MODIFIED="1577845917179" TEXT="Complexity analysis"/>
</node>
<node CREATED="1577845919299" ID="ID_1928935606" MODIFIED="1577845923432" TEXT="Implementation details">
<node CREATED="1577845923914" ID="ID_477865904" MODIFIED="1577845927395" TEXT="Range query"/>
<node CREATED="1577845927704" ID="ID_1483730850" MODIFIED="1577845931754" TEXT="Point Updates"/>
<node CREATED="1577845932487" ID="ID_460810946" MODIFIED="1577845937097" TEXT="Fenwick tree construction"/>
</node>
<node CREATED="1577845938281" ID="ID_158043942" MODIFIED="1577845941926" TEXT="Code Implementation"/>
</node>
<node CREATED="1577845977737" ID="ID_1454575431" MODIFIED="1577845980921" TEXT="Motivation">
<node CREATED="1577845981972" ID="ID_503517607" MODIFIED="1577845998077" TEXT="Given an array of integer values compute the range sum between index [i, j).">
<node CREATED="1577846037495" ID="ID_313812917" MODIFIED="1577846063379" TEXT="A = [5, -3, 6, 1, 0, -4, 11, 6, 2, 7]">
<node CREATED="1577846064059" ID="ID_1066285989" MODIFIED="1577846083765" TEXT="Sum of A from [2, 7) = 6 + 1 + 0 -4 + 11 = 14">
<node CREATED="1577846099610" ID="ID_837176097" MODIFIED="1577846102782" TEXT="Linear queries"/>
<node CREATED="1577846114047" ID="ID_1901835338" MODIFIED="1577846116231" TEXT="Solution:">
<node CREATED="1577846116558" ID="ID_1212700859" MODIFIED="1577846126967" TEXT="Let P be an array containing all the prefix sums of A">
<node CREATED="1577846198392" ID="ID_1465146885" MODIFIED="1577846224058" TEXT="P = [0, 5, 2, 8, 9, 9, 5, 16, 22, 24, 31]">
<node CREATED="1577846224736" ID="ID_1246693559" MODIFIED="1577846263797" TEXT="Sum of A from [2, 7) = P[7] - P[2] = 16 - 2 = 14">
<node CREATED="1577846302696" ID="ID_715058746" MODIFIED="1577846304497" TEXT="Flaw:">
<node CREATED="1577846304762" ID="ID_17420430" MODIFIED="1577846314075" TEXT="When we update a value in original array?">
<node CREATED="1577846316289" ID="ID_1706585361" MODIFIED="1577846324927" TEXT="We have to recompute all prefix sums">
<node CREATED="1577846325755" ID="ID_1247882874" MODIFIED="1577846327220" TEXT="O(n)"/>
</node>
<node CREATED="1577846330354" ID="ID_1138823801" MODIFIED="1577846331851" TEXT="Solution">
<node CREATED="1577846332322" ID="ID_336406329" MODIFIED="1577846335076" TEXT="Fenwick tree">
<node CREATED="1577851312088" ID="ID_791722290" MODIFIED="1577851352518" TEXT="A Fenwick Tree (also called Binary Index Tree) is a data structure that supports sum range queries as well as setting values in a static array and getting the value of the prefix sum up some index efficiently.">
<node CREATED="1577851369363" ID="ID_1976608208" MODIFIED="1577851371944" TEXT="Complexity">
<node CREATED="1577851376126" ID="ID_380211144" MODIFIED="1577851381033" TEXT="Construction: O(n)"/>
<node CREATED="1577851383470" ID="ID_571509538" MODIFIED="1577851393434" TEXT="Point Update: O(log(n))"/>
<node CREATED="1577851393922" ID="ID_1274680972" MODIFIED="1577851401257" TEXT="Range Sum: O(log(n))"/>
<node CREATED="1577851401758" ID="ID_1949918993" MODIFIED="1577851409840" TEXT="Range Update: O(log(n))"/>
<node CREATED="1577851410656" ID="ID_1093401780" MODIFIED="1577851415417" TEXT="Adding Index: N/A"/>
<node CREATED="1577851415662" ID="ID_709944726" MODIFIED="1577851421627" TEXT="Removing Index: N/A"/>
</node>
<node CREATED="1577851466929" ID="ID_922128091" MODIFIED="1577851487997" TEXT="Unline a regular array, in a Fenwick tree a specific cell is responsible for other cells as well"/>
<node CREATED="1577851509572" ID="ID_472928406" MODIFIED="1577851533583" TEXT="The position of the least significant bit (LSB) determines the range of responsibility that cell has to the cells below itself">
<node CREATED="1577851553131" ID="ID_416707826" MODIFIED="1577851672131">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      16: 10000
    </p>
    <p>
      15: 01111
    </p>
    <p>
      14: 01110
    </p>
    <p>
      13: 01101
    </p>
    <p>
      12: 01100
    </p>
    <p>
      11: 01011
    </p>
    <p>
      10: 01010
    </p>
    <p>
      &#160;&#160;9: 01001
    </p>
    <p>
      &#160;&#160;8: 01000
    </p>
    <p>
      &#160;&#160;7: 00111
    </p>
    <p>
      &#160;&#160;6: 00110
    </p>
    <p>
      &#160;&#160;5: 00101
    </p>
    <p>
      &#160;&#160;4: 00100
    </p>
    <p>
      &#160;&#160;3: 00011
    </p>
    <p>
      &#160;&#160;2: 00010
    </p>
    <p>
      &#160;&#160;1: 00001
    </p>
  </body>
</html></richcontent>
<node CREATED="1577851679295" ID="ID_240240701" MODIFIED="1577851685851" TEXT="Index 12 in binary is: 1100">
<node CREATED="1577851687190" ID="ID_764608857" MODIFIED="1577851715446" TEXT="LSB is at position 3, so this index is responsible for 2^(3-1) = 4 cells below itself"/>
<node CREATED="1577851932567" ID="ID_312857843" MODIFIED="1577851948622" TEXT="Blue bars represent the range of responsibility for that cell NOT value.">
<node CREATED="1577851949212" ID="ID_1463842237" MODIFIED="1577851989010" TEXT="All odd numbers have their first least significant bit set in the ones position, so they are only responsible for themselves."/>
</node>
<node CREATED="1577852000070" ID="ID_977650345" MODIFIED="1577852013120" TEXT="Numbers with their least significant bit in the third position have a range of four"/>
<node CREATED="1577852037733" ID="ID_877456430" MODIFIED="1577852041374" TEXT="Range Queries">
<node CREATED="1577852047504" ID="ID_117589234" MODIFIED="1577852072546" TEXT="In a Fenwick tree we may compute the prefix sum up to a certain index, which ultimately lets us perform range sum queries">
<node CREATED="1577852100062" ID="ID_419756558" MODIFIED="1577852131517" TEXT="Idea: Suppose you want to find the prefix sum of [1, i], then you start at i and cascade downwards until you reach zero adding the value at each of the indices you encounter.">
<node CREATED="1577852147941" ID="ID_873696216" MODIFIED="1577852157756" TEXT="Prefix sum up to index 7 (inclusive)">
<node CREATED="1577852198772" ID="ID_1202040447" MODIFIED="1577852212013" TEXT="sum = A[7] + A[6] + A[4]">
<node CREATED="1577852212742" ID="ID_1717066536" MODIFIED="1577852217913" TEXT="6 is responsible for 2"/>
<node CREATED="1577852218209" ID="ID_1370244906" MODIFIED="1577852227461" TEXT="4 is responsible for 4 (3 below)"/>
</node>
<node CREATED="1577852264312" ID="ID_910510175" MODIFIED="1577852279215" TEXT="Let&apos;s use prefix sums to compute the interval sum between [i, j].">
<node CREATED="1577852280524" ID="ID_1740973140" MODIFIED="1577852289116" TEXT="Compute the interval sum between [11, 15].">
<node CREATED="1577852290023" ID="ID_403089203" MODIFIED="1577852324742" TEXT="First we compute the prefix sum of [1, 15], then we will compute the prefix sum of [1, 11) and get the difference.">
<node CREATED="1577852325524" ID="ID_1211412565" MODIFIED="1577852335077" TEXT="Not inclusive! We want the value at position 11.">
<node CREATED="1577852490639" ID="ID_1512950066" MODIFIED="1577852502041" TEXT="Compute the interval sum between [11, 15].">
<node CREATED="1577852502543" ID="ID_251059867" MODIFIED="1577852525122" TEXT="First we compute the prefix sum of [1, 15], then we will compute the prefix sum of [1, 11) and get the difference">
<node CREATED="1577852526568" ID="ID_1328689811" MODIFIED="1577852548982" TEXT="Sum of [1, 15] = A[15] + A[14] + A[12] + A[8]"/>
<node CREATED="1577852549609" ID="ID_1734782226" MODIFIED="1577852569869" TEXT="Sum of [1, 11) = A[10] + A[8]"/>
<node CREATED="1577852577828" ID="ID_370907462" MODIFIED="1577852609754" TEXT="Range sum: (A[15] + A[14] + A[12] + A[8] - A[10] - A[8]"/>
</node>
<node CREATED="1577852615564" ID="ID_579885347" MODIFIED="1577852658668" TEXT="Notice that in the worst case the cell we&apos;re querying has a binary representation of all ones (numbers of the form 2^n - 1)">
<node CREATED="1577852661156" ID="ID_26440176" MODIFIED="1577852689930" TEXT="Hence, it&apos;s easy to see that in the worst case a range query might make us have to do two queries that cost log_2(n) operations"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1577852760351" ID="ID_383824271" MODIFIED="1577852769170" TEXT="Range query algorithm">
<node CREATED="1577852769823" ID="ID_1931177779" MODIFIED="1577852784709" TEXT="To do a range query from [i,j] both inclusive a Fenwick tree of size N">
<node CREATED="1577852786192" ID="ID_688088038" MODIFIED="1577852927576">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      function prefixSum(i):
    </p>
    <p>
      &#160;&#160;&#160;&#160;sum := 0
    </p>
    <p>
      &#160;&#160;&#160;&#160;while i != 0:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sum = sum + tree[i]
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;i = i - LSB(i)
    </p>
    <p>
      &#160;&#160;&#160;&#160;return sum
    </p>
    <p>
      
    </p>
    <p>
      function rangeQuery(i, j):
    </p>
    <p>
      &#160;&#160;&#160;&#160;return prefixSum(j) - prefixSum(i - 1)
    </p>
    <p>
      
    </p>
    <p>
      Where LSB returns the value of the least significant bit.
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047934157" ID="ID_1668128613" MODIFIED="1567047940049" TEXT="Fenwick tree point updates"/>
<node CREATED="1567047940961" ID="ID_814720894" MODIFIED="1567047946570" TEXT="Fenwick tree construction"/>
<node CREATED="1567047947928" ID="ID_210618531" MODIFIED="1567047952477" TEXT="Fenwick tree source code"/>
</node>
<node CREATED="1567047959209" ID="ID_1666717418" MODIFIED="1567047961852" POSITION="right" TEXT="AVL Tree">
<node CREATED="1567047962620" ID="ID_1999519162" MODIFIED="1567047965491" TEXT="Tree rotations">
<node CREATED="1579093933640" ID="ID_42969726" MODIFIED="1579093949094" TEXT="Balanced Binary Search Trees">
<node CREATED="1579093949464" ID="ID_182218959" MODIFIED="1579093957848" TEXT="What is a BBST?">
<node CREATED="1579093958648" ID="ID_1107839925" MODIFIED="1579094001925" TEXT="A Balanced Binary Search Tree (BBST) is a self-balancing binary search tree. This type of tree will adjust itself in order to maintain a low (logarithmic) height allowing for faster operations such as insertions and deletions">
<node CREATED="1579094027668" ID="ID_1676351404" MODIFIED="1579094038931" TEXT="logarithmic height in proportion to the number of nodes"/>
</node>
</node>
<node CREATED="1579094042688" ID="ID_234031541" MODIFIED="1579094136057" TEXT="Complexity">
<node CREATED="1579094137644" ID="ID_927095581" MODIFIED="1579094150368" TEXT="Ordinary Binary Search Tree">
<node CREATED="1579094047160" ID="ID_1658828037" MODIFIED="1579094054600" TEXT="Operation">
<node CREATED="1579094056328" ID="ID_1097475751" MODIFIED="1579094058488" TEXT="Insert">
<node CREATED="1579094067213" ID="ID_697158423" MODIFIED="1579094070018" TEXT="Average">
<node CREATED="1579094075558" ID="ID_659238461" MODIFIED="1579094079160" TEXT="O(log(n))"/>
</node>
<node CREATED="1579094070700" ID="ID_424752239" MODIFIED="1579094072016" TEXT="Worst">
<node CREATED="1579094072598" ID="ID_1105144433" MODIFIED="1579094074560" TEXT="O(n)"/>
</node>
</node>
<node CREATED="1579094058775" ID="ID_1761090965" MODIFIED="1579094060808" TEXT="Delete">
<node CREATED="1579094080719" ID="ID_872860342" MODIFIED="1579094082808" TEXT="Average">
<node CREATED="1579094083137" ID="ID_733659037" MODIFIED="1579094087176" TEXT="O(log(n))"/>
</node>
<node CREATED="1579094089061" ID="ID_458997549" MODIFIED="1579094091080" TEXT="Worst">
<node CREATED="1579094091309" ID="ID_373420671" MODIFIED="1579094092912" TEXT="O(n)"/>
</node>
</node>
<node CREATED="1579094061208" ID="ID_736870229" MODIFIED="1579094063272" TEXT="Remove">
<node CREATED="1579094094119" ID="ID_1877010241" MODIFIED="1579094095808" TEXT="Average">
<node CREATED="1579094096088" ID="ID_1179719166" MODIFIED="1579094098752" TEXT="O(log(n))"/>
</node>
<node CREATED="1579094101328" ID="ID_257836943" MODIFIED="1579094102537" TEXT="Worst">
<node CREATED="1579094102782" ID="ID_12629010" MODIFIED="1579094104304" TEXT="O(n)"/>
</node>
</node>
<node CREATED="1579094063588" ID="ID_1590289130" MODIFIED="1579094065776" TEXT="Search">
<node CREATED="1579094105509" ID="ID_1060010264" MODIFIED="1579094107160" TEXT="Average">
<node CREATED="1579094107382" ID="ID_584376835" MODIFIED="1579094109953" TEXT="O(log(n))"/>
</node>
<node CREATED="1579094111335" ID="ID_932972003" MODIFIED="1579094112921" TEXT="Worst">
<node CREATED="1579094113137" ID="ID_253460179" MODIFIED="1579094114481" TEXT="O(n)"/>
</node>
</node>
</node>
</node>
<node CREATED="1579094151209" ID="ID_468096101" MODIFIED="1579094159141" TEXT="Balanced Binary Search Tree">
<node CREATED="1579094047160" ID="ID_535072652" MODIFIED="1579094054600" TEXT="Operation">
<node CREATED="1579094056328" ID="ID_1827339870" MODIFIED="1579094058488" TEXT="Insert">
<node CREATED="1579094067213" ID="ID_1490796261" MODIFIED="1579094070018" TEXT="Average">
<node CREATED="1579094075558" ID="ID_1869243815" MODIFIED="1579094079160" TEXT="O(log(n))"/>
</node>
<node CREATED="1579094070700" ID="ID_408308782" MODIFIED="1579094072016" TEXT="Worst">
<node CREATED="1579094072598" ID="ID_1461122063" MODIFIED="1579094186341" TEXT="O(log(n))"/>
</node>
</node>
<node CREATED="1579094058775" ID="ID_187059269" MODIFIED="1579094060808" TEXT="Delete">
<node CREATED="1579094080719" ID="ID_1121286632" MODIFIED="1579094082808" TEXT="Average">
<node CREATED="1579094083137" ID="ID_1177884988" MODIFIED="1579094087176" TEXT="O(log(n))"/>
</node>
<node CREATED="1579094089061" ID="ID_4247595" MODIFIED="1579094091080" TEXT="Worst">
<node CREATED="1579094091309" ID="ID_937414989" MODIFIED="1579094192749" TEXT="O(log(n))"/>
</node>
</node>
<node CREATED="1579094061208" ID="ID_1257052869" MODIFIED="1579094063272" TEXT="Remove">
<node CREATED="1579094094119" ID="ID_690097875" MODIFIED="1579094095808" TEXT="Average">
<node CREATED="1579094096088" ID="ID_1332749726" MODIFIED="1579094098752" TEXT="O(log(n))"/>
</node>
<node CREATED="1579094101328" ID="ID_1004859945" MODIFIED="1579094102537" TEXT="Worst">
<node CREATED="1579094102782" ID="ID_973248483" MODIFIED="1579094200566" TEXT="O(log(n))"/>
</node>
</node>
<node CREATED="1579094063588" ID="ID_1611151126" MODIFIED="1579094065776" TEXT="Search">
<node CREATED="1579094105509" ID="ID_1436987124" MODIFIED="1579094107160" TEXT="Average">
<node CREATED="1579094107382" ID="ID_1143303336" MODIFIED="1579094109953" TEXT="O(log(n))"/>
</node>
<node CREATED="1579094111335" ID="ID_868043785" MODIFIED="1579094112921" TEXT="Worst">
<node CREATED="1579094113137" ID="ID_886025208" MODIFIED="1579094211205" TEXT="O(log(n))"/>
</node>
</node>
</node>
<node CREATED="1579094252413" ID="ID_821998499" MODIFIED="1579094253843" TEXT="How?">
<node CREATED="1579094254063" ID="ID_425717562" MODIFIED="1579094583980" TEXT="Tree Rotations!">
<node CREATED="1579094263416" ID="ID_908153197" MODIFIED="1579094282315" TEXT="The secret ingredient to most BBST algorithms is the clever usage of a tree invariant and tree rotations."/>
<node CREATED="1579094286688" ID="ID_1071640508" MODIFIED="1579094320892" TEXT="A tree invariant is a property/rule you impose on your tree that it must meet after every operation. To ensure that the invariant is always satisfied a series of tree rotations are normally applied">
<node CREATED="1579094501812" ID="ID_1098455811" MODIFIED="1579094513270" TEXT="Tree rotations are applied to maintain the invariant"/>
</node>
<node CREATED="1579094583924" ID="ID_1681542612" MODIFIED="1579094608565" TEXT="Q: Why does this work? Why are you alloed to change the structure of a tree like this?">
<node CREATED="1579094577966" ID="ID_1097124984" MODIFIED="1579094651627" TEXT="Short answer: In teh left tree we know that D &lt; B &lt; E &lt; A &lt; C and this remains true for the right subtree, so we didsn&apos;t break the BST invariant and, therefore, this is a valid transformation."/>
<node CREATED="1579094721562" ID="ID_1631011578" MODIFIED="1579094724821" TEXT="Long answer">
<node CREATED="1579094725730" ID="ID_1014065269" MODIFIED="1579094747180" TEXT="Recall that all BBSTs are BSTs so the BST invariant holds. This means that for every node n, n.left &lt; n and n &lt; n.right.">
<node CREATED="1579094749243" ID="ID_1285673698" MODIFIED="1579094797398" TEXT="NOTE: The above assumes we only have unique values, otherwise we&apos;d have to consider the case where n.left &lt;= n and n &lt;= n.right"/>
<node CREATED="1579094802173" ID="ID_681905297" MODIFIED="1579094844481" TEXT="It does not matter what the structure of the tree looks; all we care about is that the BST invariant holds. This means we can shuffle/ transform/ rotate the values and nodes in the tree as we please as long as the BST invariant remains satisfied!"/>
</node>
</node>
</node>
<node CREATED="1579094870115" ID="ID_694705785" MODIFIED="1579094874147" TEXT="Right Rotations">
<node CREATED="1579094874763" ID="ID_1879457950" MODIFIED="1579094983777">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      function right Rotate(A):
    </p>
    <p>
      &#160;&#160;&#160;&#160;B := A.left
    </p>
    <p>
      &#160;&#160;&#160;&#160;A.left = B.right
    </p>
    <p>
      &#160;&#160;&#160;&#160;B.right = A
    </p>
    <p>
      &#160;&#160;&#160;&#160;return B
    </p>
  </body>
</html></richcontent>
<node CREATED="1579095017317" ID="ID_149684406" MODIFIED="1579095028725" TEXT="Parent P may or may not exist">
<node CREATED="1579095030948" ID="ID_367003070" MODIFIED="1579095102406" TEXT="If P exists, then B must be the child of P">
<node CREATED="1579095104483" ID="ID_1651779430" MODIFIED="1579095162967" TEXT="NOTE: It&apos;s possible that before the rotation node A had a parent whose left/right pointer referenced it. It&apos;s very iportant that this link be updated to reference B. This is usually done on the recursive callback using the return value of rotateRight."/>
</node>
</node>
</node>
</node>
<node CREATED="1579094998227" ID="ID_1421010278" MODIFIED="1579095002126" TEXT="Left Rotations"/>
<node CREATED="1579095232966" ID="ID_313260436" MODIFIED="1579095301661" TEXT="In some BBST implementations where you often need to access the parent/uncle nodes (such as RB trees), it&apos;s convenient for nodes to not only have a reference to the left and the right child nodes but also the parent node. This can complicate tree rotations because instead of updating three pointers, now you have to update six!">
<node CREATED="1579095350277" ID="ID_1109986124" MODIFIED="1579095356668" TEXT="RB: Red Black Trees"/>
<node CREATED="1579095389478" ID="ID_1762656858" MODIFIED="1579095532066">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      function rightRotate(A):
    </p>
    <p>
      &#160;&#160;&#160;&#160;P := A.parent
    </p>
    <p>
      &#160;&#160;&#160;&#160;B := A.left
    </p>
    <p>
      &#160;&#160;&#160;&#160;A.left = B.right
    </p>
    <p>
      &#160;&#160;&#160;&#160;if B.right != null:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;B.right.parent = A
    </p>
    <p>
      &#160;&#160;&#160;&#160;B.right = A
    </p>
    <p>
      &#160;&#160;&#160;&#160;A.parent = B
    </p>
    <p>
      &#160;&#160;&#160;&#160;B.parent = P
    </p>
    <p>
      &#160;&#160;&#160;&#160;# Update parent down link.
    </p>
    <p>
      &#160;&#160;&#160;&#160;if P != null:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if P.left == A:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;P.left = B
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;P.right = B
    </p>
    <p>
      &#160;&#160;&#160;&#160;return B
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node CREATED="1579095737315" ID="ID_770022336" MODIFIED="1579095767789" TEXT="Summary: BBSTs remain balanced by performing a series of left/right tree rotations when their invariant is not satisfied."/>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047966997" ID="ID_1916570050" MODIFIED="1567047973404" TEXT="AVL tree insertions">
<node CREATED="1579095803185" ID="ID_600708070" MODIFIED="1579095809265" TEXT="AVL Tree Introduction">
<node CREATED="1579095812386" ID="ID_700587606" MODIFIED="1579095842345" TEXT="An AVL tree is one of many types of Balanced Binary Search Trees (BBSTs) which allow for logarightmic O(log(n)) insertion, deletion and search operations."/>
<node CREATED="1579095843855" ID="ID_161638485" MODIFIED="1579095894265" TEXT="In fact, it was the first type of BBST to be discovered. Soon after, many other types of BBSTs started to emerge including the 2-33 tree, the AA tree, the scapegoat tree, and its main rival, the red-black tree."/>
</node>
<node CREATED="1579095943398" ID="ID_1975901335" MODIFIED="1579095949383" TEXT="AVL Tree Invariant">
<node CREATED="1579095955347" ID="ID_1448879101" MODIFIED="1579095975951" TEXT="The property which keeps an AVL tree balanced is called the Balanced Factor (BF).">
<node CREATED="1579095977109" ID="ID_437288640" MODIFIED="1579095987943" TEXT="BF(node) = H(node.right) - H(node.left)">
<node CREATED="1579095990230" ID="ID_1881550410" MODIFIED="1579096015504" TEXT="Where H(x) is the height of node x. Recall that H9x) is calculated as the number of edges between x and the furthest leaf."/>
<node CREATED="1579096031566" ID="ID_1154959541" MODIFIED="1579096065007" TEXT="The invariant in the AVL which forces it to remain balanced is the requirement that the balance factor is always either -1, 0. or +1">
<node CREATED="1579096136875" ID="ID_616406160" MODIFIED="1579096147160" TEXT="If tree has only one node, H(x) = 0"/>
</node>
</node>
</node>
</node>
<node CREATED="1579096163584" ID="ID_1131978128" MODIFIED="1579096167514" TEXT="Node information to store">
<node CREATED="1579096167759" ID="ID_685519228" MODIFIED="1579096185907" TEXT="The actual value we&apos;re storing in the node. NOTE: THis value must be comparable so we know how to insert it."/>
<node CREATED="1579096187636" ID="ID_1925609243" MODIFIED="1579096196003" TEXT="A value storing this node&apos;s balance factor."/>
<node CREATED="1579096204665" ID="ID_1708276508" MODIFIED="1579096211875" TEXT="The height of this node in the tree"/>
<node CREATED="1579096212615" ID="ID_1694179393" MODIFIED="1579096219875" TEXT="Pointers to the left/right child nodes."/>
</node>
<node CREATED="1579096257802" ID="ID_643974396" MODIFIED="1579096273046" TEXT="Q: What if the BF of a node is not in {-1, 0, +1}?">
<node CREATED="1579096275072" ID="ID_94888803" MODIFIED="1579096285221" TEXT="How do we restore the AVL tree invariant?">
<node CREATED="1579096286937" ID="ID_259901414" MODIFIED="1579096316627" TEXT="A: If a node&apos;s BF is not in {-1, 0, +1} then the BF of that node is +/- 2 which can be adjusted using tree rotations.">
<node CREATED="1579096317816" ID="ID_716751821" MODIFIED="1579096329421" TEXT="BF(node) = H(node.right) - H(node.left)">
<node CREATED="1579096342754" ID="ID_176669732" MODIFIED="1579096361415" TEXT="If BF is -2, then right rotate">
<node CREATED="1579096435203" ID="ID_1959180588" MODIFIED="1579096437973" TEXT="Left heavy"/>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1579096458532" ID="ID_528377350" MODIFIED="1579096462429" TEXT="Different cases">
<node CREATED="1579096462659" ID="ID_1580590152" MODIFIED="1579096465357" TEXT="left heavy">
<node CREATED="1579096465677" ID="ID_710709437" MODIFIED="1579096477227" TEXT="right rotation"/>
</node>
<node CREATED="1579096478153" ID="ID_1507100491" MODIFIED="1579096480947" TEXT="left right case">
<node CREATED="1579096487113" ID="ID_1640467808" MODIFIED="1579096544915" TEXT="left rotate about left child (becomes left heavy)">
<node CREATED="1579096514676" ID="ID_661407284" MODIFIED="1579096519620" TEXT="right rotate"/>
</node>
</node>
<node CREATED="1579096552747" ID="ID_461095984" MODIFIED="1579096556188" TEXT="right right case">
<node CREATED="1579096556480" ID="ID_1949126797" MODIFIED="1579096567009" TEXT="left rotation about right child"/>
</node>
<node CREATED="1579096568978" ID="ID_162683305" MODIFIED="1579096572532" TEXT="right left case">
<node CREATED="1579096572880" ID="ID_696177875" MODIFIED="1579096582204" TEXT="right rotate about right child (becomes right heavy)">
<node CREATED="1579096582794" ID="ID_1750342474" MODIFIED="1579096585788" TEXT="left rotate"/>
</node>
</node>
</node>
<node CREATED="1579096595787" ID="ID_797890151" MODIFIED="1579096600589" TEXT="Pseudocode">
<node CREATED="1579096601120" ID="ID_1035435449" MODIFIED="1579096699733">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      # Public facing insert method. Returns true
    </p>
    <p>
      # on successful insert and false otherwise.
    </p>
    <p>
      function insert(value):
    </p>
    <p>
      &#160;
    </p>
    <p>
      &#160;&#160;&#160;&#160;if value == null:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;&#160;&#160;# Only insert unique values
    </p>
    <p>
      &#160;&#160;&#160;&#160;if !contains(root, value):
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;root = insert(root, value)
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nodeCount = nodeCount + 1
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return true
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;&#160;&#160;# Value already exists in tree.
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return false
    </p>
  </body>
</html></richcontent>
<node CREATED="1579226783419" ID="ID_116654620" MODIFIED="1579226929517">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      function insert(node, value):
    </p>
    <p>
      &#160;&#160;&#160;&#160;if node == null: return Node(value)
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;&#160;&#160;# Invoke the comparator function in whatever
    </p>
    <p>
      &#160;&#160;&#160;&#160;# programming language you're using
    </p>
    <p>
      &#160;&#160;&#160;&#160;cmp := compare(value, node.value)
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;&#160;&#160;if cmp &lt; 0:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node.left = insert(node.left, value)
    </p>
    <p>
      &#160;&#160;&#160;&#160;else:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;node.right = insert(node.right, value)
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;&#160;&#160;# Update balance factor and height values.
    </p>
    <p>
      &#160;&#160;&#160;&#160;update(node)
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;&#160;&#160;# Rebalance tree
    </p>
    <p>
      &#160;&#160;&#160;&#160;return balance(node)
    </p>
  </body>
</html></richcontent>
<node CREATED="1579226966189" ID="ID_527979982" MODIFIED="1579227052154">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      function update(node):
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;&#160;&#160;# Variables for left/right subtree heights
    </p>
    <p>
      &#160;&#160;&#160;&#160;lh := -1
    </p>
    <p>
      &#160;&#160;&#160;&#160;rh := -1
    </p>
    <p>
      &#160;&#160;&#160;&#160;if node.left != null: lh = node.left.height
    </p>
    <p>
      &#160;&#160;&#160;&#160;if node.right != null: rh = node.right.height
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;&#160;&#160;# Update this node's height
    </p>
    <p>
      &#160;&#160;&#160;&#160;node.height = 1 + max(lh, rh)
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;&#160;&#160;# Update balance factor.
    </p>
    <p>
      &#160;&#160;&#160;&#160;node.bf = rh - lh
    </p>
  </body>
</html></richcontent>
<node CREATED="1579227081293" ID="ID_855289016" MODIFIED="1579227118293" TEXT="-1 because if it is added to height of tree with 0 height, it becomes 0"/>
<node CREATED="1579227133977" ID="ID_541653073" MODIFIED="1579227256827">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      function balance(node):
    </p>
    <p>
      &#160;&#160;&#160;&#160;# Left heavy subtree.
    </p>
    <p>
      &#160;&#160;&#160;&#160;if node.bf == -2:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if node.left.bf &lt;= 0:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return leftLeftCase(node)
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return leftRightCase(node)
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;&#160;&#160;# Right heavy subtree.
    </p>
    <p>
      &#160;&#160;&#160;&#160;else if node.bf == +2:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if node.right.bf &gt;= 0:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return rightRightCase(node)
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return rightLeftCase(node)
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;&#160;&#160;# Node has balance factor of -1, 0, or +1
    </p>
    <p>
      &#160;&#160;&#160;&#160;# which we do not need to balance
    </p>
    <p>
      &#160;&#160;&#160;&#160;return node
    </p>
  </body>
</html></richcontent>
<node CREATED="1579227274260" ID="ID_378724280" MODIFIED="1579227354442">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      function leftLeftCase(node):
    </p>
    <p>
      &#160;&#160;&#160;&#160;return rightRotation(node)
    </p>
    <p>
      
    </p>
    <p>
      function leftRightCase(node):
    </p>
    <p>
      &#160;&#160;&#160;&#160;node.left = leftRotation(node.left)
    </p>
    <p>
      &#160;&#160;&#160;&#160;return leftLeftCase(node)
    </p>
    <p>
      
    </p>
    <p>
      function rightRightCase(node):
    </p>
    <p>
      &#160;&#160;&#160;&#160;return leftRotation(node)
    </p>
    <p>
      
    </p>
    <p>
      function rightLeftCase(node):
    </p>
    <p>
      &#160;&#160;&#160;&#160;node.right = rightRotation(node.right)
    </p>
    <p>
      &#160;&#160;&#160;&#160;return rightRightCase(node)
    </p>
  </body>
</html></richcontent>
<node CREATED="1579227389334" ID="ID_432613421" MODIFIED="1579227457698">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      function rightRotate(A):
    </p>
    <p>
      &#160;&#160;&#160;&#160;B := A.left
    </p>
    <p>
      &#160;&#160;&#160;&#160;A.left = B.right
    </p>
    <p>
      &#160;&#160;&#160;&#160;B.right = A
    </p>
    <p>
      &#160;&#160;&#160;&#160;# After rotation update balance
    </p>
    <p>
      &#160;&#160;&#160;&#160;# factor and height values.
    </p>
    <p>
      &#160;&#160;&#160;&#160;update(A)
    </p>
    <p>
      &#160;&#160;&#160;&#160;update(B)
    </p>
    <p>
      &#160;&#160;&#160;&#160;return B
    </p>
  </body>
</html></richcontent>
<node CREATED="1579227458873" ID="ID_1640051097" MODIFIED="1579227475516" TEXT="AVL tree rotations require you to call the update method! The left rotation is symmetric">
<node CREATED="1579227492175" ID="ID_1125035920" MODIFIED="1579227498659" TEXT="Height, balance factor"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047975034" ID="ID_994624740" MODIFIED="1567047980588" TEXT="AVL tree removals">
<node CREATED="1579227595918" ID="ID_1144833440" MODIFIED="1579227604219" TEXT="Removing Elements from a BST">
<node CREATED="1579227609093" ID="ID_1557558151" MODIFIED="1579227613405" TEXT="Two step process">
<node CREATED="1579227613651" ID="ID_1333323297" MODIFIED="1579227658292">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <ol>
      <li>
        Find the element we wish to remove (if it exists).
      </li>
      <li>
        Replace the node we want to remove with its successor (if any) to maintain the BST invariant.
      </li>
    </ol>
  </body>
</html></richcontent>
<node CREATED="1579227661062" ID="ID_1416258298" MODIFIED="1579227676191" TEXT="BST invariant: left subtree has smaller elements and right subtree has larger elements."/>
<node CREATED="1579227708526" ID="ID_494708944" MODIFIED="1579227711728" TEXT="Find phase">
<node CREATED="1579227711942" ID="ID_246009847" MODIFIED="1579227734611" TEXT="When searching for an element, one of 4 things can happen">
<node CREATED="1579227735412" ID="ID_1654478131" MODIFIED="1579227798660">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <ol>
      <li>
        We hit a null node at which point we know the value does not exist within our BST
      </li>
      <li>
        Comparator value equal to 0 (found it!)
      </li>
      <li>
        Comparator value less than 0 (the value, if it exists, is in the left subtree)
      </li>
      <li>
        Comparator value greater than 0 (the value, if it exists, is in the right subtree)
      </li>
    </ol>
  </body>
</html></richcontent>
<node CREATED="1579234658734" ID="ID_965855049" MODIFIED="1579234662694" TEXT="find(14)"/>
<node CREATED="1579350355708" ID="ID_941659754" MODIFIED="1579350360295" TEXT="Remove Phase">
<node CREATED="1579350360664" ID="ID_1889821671" MODIFIED="1579350363806" TEXT="Four cases">
<node CREATED="1579350368816" ID="ID_1012747742" MODIFIED="1579350376341" TEXT="1. Node to remove is a leaf node">
<node CREATED="1579351535871" ID="ID_857308190" MODIFIED="1579351541623" TEXT="Case I: Leaf node">
<node CREATED="1579351542651" ID="ID_655691814" MODIFIED="1579351555543" TEXT="If the node we wish to remove is a leaf node then we may do so without side effect"/>
<node CREATED="1579351563112" ID="ID_1841579799" MODIFIED="1579351589332" TEXT="Suppose we want to remove 8 from the BST on the right. First we would find 8 then remove it immediately since it&apos;s a leaf node"/>
</node>
</node>
<node CREATED="1579350377144" ID="ID_533668289" MODIFIED="1579350387695" TEXT="2. Node to remove has a right subtree but no left subtree">
<node CREATED="1579351914978" ID="ID_1152937955" MODIFIED="1579351929381" TEXT="Case II &amp; III: either the left/right child node is a subtree">
<node CREATED="1579351930042" ID="ID_1852427935" MODIFIED="1579351951002" TEXT="The successor of the node we are trying to remove in these cases will be the immediate node down from the left/right subtree"/>
<node CREATED="1579351956648" ID="ID_1090430397" MODIFIED="1579351980392" TEXT="It may be the case that we are removing the root node of the BST, in which case its immediate child becomes the new root, as you would expect"/>
</node>
</node>
<node CREATED="1579350388064" ID="ID_757733435" MODIFIED="1579350399362" TEXT="3. Node to remove has a left subtree but no right subtree"/>
<node CREATED="1579350399607" ID="ID_744645281" MODIFIED="1579350413184" TEXT="4. Note to remove has both left subtree and a right subtree">
<node CREATED="1579352165868" ID="ID_1799216853" MODIFIED="1579352179297" TEXT="Case IV: Node to remove has both a left subtree and a right subtree">
<node CREATED="1579352180386" ID="ID_1576922143" MODIFIED="1579352193184" TEXT="Q: In which subtree will the successor of the node we are tyring to remove be?">
<node CREATED="1579352201001" ID="ID_1249043285" MODIFIED="1579352226723" TEXT="A: The answer is both! The successor can either be the largest value in the left subtree OR the smallest value in the right subtree ">
<node CREATED="1579352242539" ID="ID_614386155" MODIFIED="1579352267813" TEXT="Once the successor node has been identified (if it exists), replace the value of the node to remove with teh value in the successor node.">
<node CREATED="1579352273989" ID="ID_596810682" MODIFIED="1579352326663" TEXT="NOTE: Don&apos;t forget to remove the duplicate value of the successor node that still exists in the tree at this point! One strategy to resolve this is by calling the function again recursively but with the value to remove as the value in the successor node.">
<node CREATED="1579352439614" ID="ID_1890603907" MODIFIED="1579352452046" TEXT="This will only result in Case I, II or III removal"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1579351125470" ID="ID_854498735" MODIFIED="1579351131023" TEXT="Removing Elements from a BST">
<node CREATED="1579351153747" ID="ID_1107439609" MODIFIED="1579351174405" TEXT="Removing elements from a Binary Search Tree (BST) can be seen as a two-step process:">
<node CREATED="1579351174925" ID="ID_557906775" MODIFIED="1579351186804" TEXT="1. Find the element we wish to remove (if it exists).">
<node CREATED="1579351299384" ID="ID_1037544518" MODIFIED="1579351318040" TEXT="When searching our BST for a node with a particular value, one of four things will happen:">
<node CREATED="1579351318439" ID="ID_906527826" MODIFIED="1579351338070" TEXT="1. We hit a null node at which point we know the value does not exist within our BST"/>
<node CREATED="1579351338670" ID="ID_1693899714" MODIFIED="1579351348201" TEXT="2. Comparator value equal to 0 (found it!)"/>
<node CREATED="1579351348703" ID="ID_1670976662" MODIFIED="1579351367337" TEXT="3. Comparator value less than 0 (the value, if it exists, is in the left subtree)"/>
<node CREATED="1579351368266" ID="ID_694818398" MODIFIED="1579351384522" TEXT="4. Comparator value greater than 0 (the value, if it exists, is in the right subtree)"/>
</node>
</node>
<node CREATED="1579351187297" ID="ID_13185242" MODIFIED="1579351204836" TEXT="2. Replace the node we want to remove with its successor (if any) to maintain the BST invariant.">
<node CREATED="1579351220438" ID="ID_1086451941" MODIFIED="1579351236927" TEXT="BST invariant: left subtree has smaller elements and right subtree has larger elements"/>
</node>
</node>
</node>
<node CREATED="1579352491591" ID="ID_679861129" MODIFIED="1579352503252" TEXT="Augmenting BST Removal Algorithm for AVL Tree">
<node CREATED="1579352503900" ID="ID_79005883" MODIFIED="1579352526056" TEXT="Augmenting the removal algorithm from a plain BST implementation to an AVL tree is just as easy as adding two lines of code:">
<node CREATED="1579352527416" ID="ID_842378358" MODIFIED="1579352578148">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      function remove(node, value):
    </p>
    <p>
      &#160;&#160;&#160;&#160;...
    </p>
    <p>
      &#160;&#160;&#160;&#160;# Code for BST item removal here
    </p>
    <p>
      &#160;&#160;&#160;&#160;...
    </p>
    <p>
      &#160;
    </p>
    <p>
      &#160;&#160;&#160;&#160;# Update balance factor
    </p>
    <p>
      &#160;&#160;&#160;&#160;update(node)
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;&#160;&#160;# Rebalance tree
    </p>
    <p>
      &#160;&#160;&#160;&#160;return balance(tree)
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567047981371" ID="ID_76219402" MODIFIED="1567047986021" TEXT="AVL tree source code"/>
</node>
<node CREATED="1591450123024" ID="ID_460644724" MODIFIED="1591450128886" POSITION="right" TEXT="Sparse Tables">
<node CREATED="1591452862873" ID="ID_293282513" MODIFIED="1591452866451" TEXT="Motivation">
<node CREATED="1591452867670" ID="ID_925580796" MODIFIED="1591452900575" TEXT="Sparse tables are all about doing efficient range queries on static arrays. Range queries come in a variety of flavors, but the most common types are min, max, sum, and gcd range queries"/>
<node CREATED="1591452911153" ID="ID_1413505100" MODIFIED="1591452940512" TEXT="For instance, we want to know the maximum value between [4, 12], the gcd between [6, 9] or even the sum of the values between [2, 11]"/>
</node>
<node CREATED="1591452955337" ID="ID_1763458274" MODIFIED="1591452961010" TEXT="Sparse table intuition">
<node CREATED="1591452962227" ID="ID_1968632473" MODIFIED="1591452989247" TEXT="Every positive integer can easily be represented as a sum of powers of 2 by its binary representation:">
<node CREATED="1591452989697" ID="ID_1007407511" MODIFIED="1591453004169" TEXT="19 = 10011 = 2^4 + 2^1 + 2^0 = 19"/>
</node>
<node CREATED="1591453006342" ID="ID_1345153366" MODIFIED="1591453167840">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Similarly, any interval [l, r] can be broken down into smaller intervals of powers of 2:
    </p>
  </body>
</html>
</richcontent>
<node CREATED="1591453026172" ID="ID_1735897093" MODIFIED="1591453094775" TEXT="[5, 17] = [5, 5 + 2^3) U [13, 13 + 2^2) U [17, 17 + 2^0) = [5, 13) U [13, 17) U [17, 18)"/>
</node>
<node CREATED="1591453103275" ID="ID_1848113019" MODIFIED="1591453127650" TEXT="Now, imagine if we could precompute the range query answer (i.e min, max, sum...) for all these intervals and combine them..."/>
</node>
<node CREATED="1591453200957" ID="ID_550700241" MODIFIED="1591453206226" TEXT="Range combination function">
<node CREATED="1591453212120" ID="ID_652088571" MODIFIED="1591453242043" TEXT="A sparse table can help up answer all these questions efficiently. For associative functions, a sparse table can answer range queries in O(log_2 (n))"/>
<node CREATED="1591453251447" ID="ID_67468090" MODIFIED="1591453269563" TEXT="A function f(x, y) is associative if: f(a, f(b, c)) = f(f(a, b), c) for all a, b, c"/>
<node CREATED="1591453282278" ID="ID_1516763752" MODIFIED="1591453313893" TEXT="Operations such as addition and multiplication are associative, but functions like subtraction and exponentiation are not. Her&apos;s a counterexample proving subtraction si not associative:">
<node CREATED="1591453315117" ID="ID_1866303608" MODIFIED="1591453320501" TEXT="Let f(a, b) = a - b">
<node CREATED="1591453322091" ID="ID_547419118" MODIFIED="1591453353540">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      f(1, g(2, 3)
    </p>
    <p>
      = f(1, 2 - 3)
    </p>
    <p>
      = 1 - (2 - 3)
    </p>
    <p>
      = 2
    </p>
  </body>
</html>
</richcontent>
</node>
<node CREATED="1591453354901" ID="ID_869329539" MODIFIED="1591453388976">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      f(g(1, 2), 3)
    </p>
    <p>
      = f(1 - 2, 3)
    </p>
    <p>
      = (1 - 2) - 3
    </p>
    <p>
      = -4
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
<node CREATED="1591453418223" ID="ID_1890522238" MODIFIED="1591453425734" TEXT="Order of operations does not matter"/>
</node>
<node CREATED="1591453440385" ID="ID_1739675308" MODIFIED="1591453475736" TEXT="Logarithmic time range queries are really good, however we can do better. When the range query combination function is &quot;overlap friendly&quot;, then range queries on a sparse table can be answered in O(1)">
<node CREATED="1591454327953" ID="ID_453655906" MODIFIED="1591454334921" TEXT="overlap agnostic may be"/>
</node>
<node CREATED="1591453643664" ID="ID_968143380" MODIFIED="1591453693503" TEXT="Being overlap friendly means a function yields the same answer regardless of whether it is combining ranges which overlap or those that do not."/>
<node CREATED="1591453695728" ID="ID_1290395241" MODIFIED="1591453967847" TEXT="We say a binary function f(x, y)  is overlap friendly if:">
<node CREATED="1591453968929" ID="ID_1904766902" MODIFIED="1591453985940" TEXT="f(f(a, b), f(b, c)) = f(a, f(b, c)) for all valid a, b, c"/>
</node>
<node CREATED="1591457003883" ID="ID_1164923113" MODIFIED="1591457011914" TEXT="Example:">
<node CREATED="1591457013547" ID="ID_1711078229" MODIFIED="1591457019204" TEXT="Let f(x, y) = x + y">
<node CREATED="1591457020807" ID="ID_765211508" MODIFIED="1591457034767" TEXT="r1 = 16, r2 = 7, r3 = 18">
<node CREATED="1591457054097" ID="ID_1470635131" MODIFIED="1591457064104" TEXT="f(f(r1, r2), f(r2, r3))">
<node CREATED="1591457084430" ID="ID_1450163092" MODIFIED="1591457099441" TEXT="= f(f(16, 7), f(7, 18) = f(23, 25) = 48"/>
</node>
<node CREATED="1591457120846" ID="ID_1225682416" MODIFIED="1591457138905" TEXT="f(r1, f(r2, r3)) = f(16, f(7, 18)) = f(16, 25) = 41"/>
</node>
<node CREATED="1591457105318" ID="ID_657201551" MODIFIED="1591457114182" TEXT="summation function double counts the middle interval">
<node CREATED="1591457145548" ID="ID_730734538" MODIFIED="1591457152694" TEXT="f(x, y) is not overlap friendly"/>
</node>
</node>
<node CREATED="1591457214447" ID="ID_1176678677" MODIFIED="1591457223859" TEXT="Which of the functions are &quot;overlap friendly&quot;?">
<node CREATED="1591457224363" ID="ID_161620663" MODIFIED="1591457230128" TEXT="f(a, b) = 1 * b">
<node CREATED="1591457287076" ID="ID_654484436" MODIFIED="1591457288772" TEXT="yes"/>
</node>
<node CREATED="1591457230965" ID="ID_173819023" MODIFIED="1591457236256" TEXT="f(a, b) = a * b">
<node CREATED="1591457326112" ID="ID_386699300" MODIFIED="1591457328027" TEXT="no"/>
</node>
<node CREATED="1591457237092" ID="ID_1044657745" MODIFIED="1591457243399" TEXT="f(a, b) = min(a, b)">
<node CREATED="1591457389853" ID="ID_1525537821" MODIFIED="1591457391450" TEXT="yes"/>
</node>
<node CREATED="1591457244628" ID="ID_1315781601" MODIFIED="1591457249823" TEXT="f(a, b) = max(a, b)">
<node CREATED="1591457392523" ID="ID_967778148" MODIFIED="1591457396301" TEXT="yes"/>
</node>
<node CREATED="1591457250932" ID="ID_274331044" MODIFIED="1591457257070" TEXT="f(a, b) = a + b">
<node CREATED="1591457397825" ID="ID_1760545934" MODIFIED="1591457399565" TEXT="no"/>
</node>
<node CREATED="1591457257572" ID="ID_1851283608" MODIFIED="1591457261982" TEXT="f(a, b) = a - b">
<node CREATED="1591457400876" ID="ID_369828917" MODIFIED="1591457402261" TEXT="no"/>
</node>
<node CREATED="1591457262837" ID="ID_877514924" MODIFIED="1591457272913" TEXT="f(a, b) = (a * b) / a, a != 0">
<node CREATED="1591457403691" ID="ID_1189118236" MODIFIED="1591457443026" TEXT="yes"/>
</node>
<node CREATED="1591457274656" ID="ID_134676741" MODIFIED="1591457281430" TEXT="f(a, b) = gcd(a, b)">
<node CREATED="1591457444706" ID="ID_1196838807" MODIFIED="1591457456399" TEXT="yes"/>
</node>
</node>
</node>
<node CREATED="1591457479561" ID="ID_1065700821" MODIFIED="1591457488634" TEXT="Table construction">
<node CREATED="1591457490282" ID="ID_1003545883" MODIFIED="1591457523866" TEXT="The idea behind a sparse table is to precompute the answer for all intervals of size 2^x to efficiently answer range queries between [l, r]."/>
<node CREATED="1591457785922" ID="ID_1201615244" MODIFIED="1591457808952" TEXT="Let N be the size of the input values array, and let 2^P be the largest power of 2 that fits in the length of the values array">
<node CREATED="1591457825959" ID="ID_1431334031" MODIFIED="1591457838164" TEXT="P = floor(log_2 (N))">
<node CREATED="1591457839075" ID="ID_1264187516" MODIFIED="1591457847340" TEXT="floor(log_2 (13)) = 3"/>
</node>
<node CREATED="1591458577414" ID="ID_25290333" MODIFIED="1591458596399" TEXT="[4, 2, 3, 7, 1, 5, 3, 3, 9, 6, 7, -1, 4]"/>
</node>
<node CREATED="1591466726155" ID="ID_635101113" MODIFIED="1591466730398" TEXT="Table construction">
<node CREATED="1591466731442" ID="ID_301049615" MODIFIED="1591466820633" TEXT="Begin by initializing a table with P + 1 rows and N columns. Then , fill the first row with the input values&#xa;&#xa;Each cell (i, j) represents the answer for the range [j, j + 2^i) in the original array">
<node CREATED="1591466825524" ID="ID_564026649" MODIFIED="1591466862349" TEXT="Example: cell (2, 5) represents the answer for the range [5, 9). If we&apos;re building a min sparse table, then the blue cell would have a value of 3">
<node CREATED="1591466886558" ID="ID_1541130435" MODIFIED="1591466902397" TEXT="4 2 3 7 1 5 3 3 9 6 7 -1 4"/>
</node>
<node CREATED="1591466976847" ID="ID_1333103790" MODIFIED="1591466996753" TEXT="The cell (3, 2) represents the answer for the range [2, 10)">
<node CREATED="1591467011653" ID="ID_1028937942" MODIFIED="1591467047119" TEXT="[2, 2 + 2^3)"/>
</node>
<node CREATED="1591467060982" ID="ID_951709336" MODIFIED="1591467077002" TEXT="The cell (1, 7) represents the answer for the range [7, 9)">
<node CREATED="1591467078146" ID="ID_46562696" MODIFIED="1591467125763" TEXT="[7, 7 + 2^1)"/>
</node>
<node CREATED="1591467150198" ID="ID_1705693282" MODIFIED="1591467177531" TEXT="What do we do about the cell (2, 10) which represents the range [10, 14)? This interval reaches outside the bounds of the sparse table.">
<node CREATED="1591467199260" ID="ID_1254383877" MODIFIED="1591467213587" TEXT="We don&apos;t need to consider partial ranges, so we can simply ignore this cell">
<node CREATED="1591467223156" ID="ID_1067608247" MODIFIED="1591467230147" TEXT="all cells with invalid intervals"/>
</node>
</node>
</node>
<node CREATED="1591466787878" ID="ID_798677111" MODIFIED="1591467261720" TEXT="We want to build a min sparse table to be able to do min range queries">
<node CREATED="1591467262571" ID="ID_88256791" MODIFIED="1591467285830" TEXT="To do min range queries we&apos;ll need the range combination function f(x, y) = min(xy, y) to combine range values">
<node CREATED="1591467291516" ID="ID_574316042" MODIFIED="1591467309598" TEXT="4 2 3 7 1 5 3 3 9 6 7 -1 4">
<node CREATED="1591467317498" ID="ID_538103339" MODIFIED="1591467446888" TEXT="More specifically, the range for the cell (i, j) can be split into a left interval [j, j + 2^(i - 1)) and a right interval [j + 2^(i - 1), j + 2^i) whose values would correspond to the cells (i - 1, j) and (i - 1, j + 2^(i - 1)) respectively."/>
<node CREATED="1591467528400" ID="ID_1413675295" MODIFIED="1591467545874" TEXT="We can finish filling the sparse table by combining values from the previous rows (dynamic programming).">
<node CREATED="1591467546891" ID="ID_518268089" MODIFIED="1591467591603" TEXT="dp[i][j] = f(dp[i - 1][j], dp[i - 1][j + 2^(i - 1)]) = min(dp[i - 1][j], dp[i - 1][j + 2^(i - 1)])"/>
<node CREATED="1591467598905" ID="ID_205624320" MODIFIED="1591467606946" TEXT="f(4, 2) = min(4, 2) = 2">
<node CREATED="1591467615404" ID="ID_1309701035" MODIFIED="1591467696506">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      4 2 3 7 1 5 3 3 9 6 7 -1 4
    </p>
    <p>
      2 2 3 1 1 3 3 3 6 6 -1 -1
    </p>
    <p>
      2 1 1 1 1 3 3 3 -1 -1
    </p>
    <p>
      1 1 1 1 -1 -1
    </p>
  </body>
</html>
</richcontent>
<node CREATED="1591467707330" ID="ID_1366747053" MODIFIED="1591467717148" TEXT="Q: What is the minimum value between [1, 11]?">
<node CREATED="1591467723576" ID="ID_197637120" MODIFIED="1591467855601" TEXT="In the table we&apos;ve already precomputed the answer for all intervals of length 2^x. Let k be the largest power of two that fits in the length of the range between [l, r].&#xa;&#xa;Knowing k we can easily do a lookup in the table to find the minimum in between the ranges [l, l + k] (left interval) and [r - k + 1, r] (right interval) to find the answer for [l, r]. The left and right intervals may overlap, but this doesn&apos;t matter (given the overlap friendly property) so log as the entire range is covered.">
<node CREATED="1591467920284" ID="ID_1532092369" MODIFIED="1591467965489" TEXT="f(f(1, 8), f(4, 11)) = f(1, -1) = -1"/>
</node>
<node CREATED="1591467991446" ID="ID_1874143584" MODIFIED="1591468011422" TEXT="Find the value of p, which gives the largest 2^p that fits in the range [1, 11].">
<node CREATED="1591468012271" ID="ID_551663287" MODIFIED="1591468026145" TEXT="len = l  - r + 1 = 11 - 1 + 1 # interval length">
<node CREATED="1591468027396" ID="ID_736569582" MODIFIED="1591468048790" TEXT="p = floor(log_2 (len)) = floor(3.321) = 3 =&gt; k = 2^p = 2^3 = 8"/>
</node>
</node>
<node CREATED="1591468096675" ID="ID_952619153" MODIFIED="1591468119082" TEXT="Knowing p = 3 (index of row 3 in the table) and k = 2^p we can do a lookup for the left and right interval ranges:">
<node CREATED="1591468120161" ID="ID_1122085019" MODIFIED="1591468306101">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      min(t[p][l], t[p][r - k + 1])
    </p>
    <p>
      min(t[3][1], t[3][11 - 8 + 1])
    </p>
    <p>
      min(t[3][1], t[3][4])
    </p>
    <p>
      min(1 , -1)
    </p>
    <p>
      = -1
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
</node>
<node CREATED="1591468200056" ID="ID_694262757" MODIFIED="1591468219397" TEXT="Q: What is the minimum value between [2, 7]?">
<node CREATED="1591468240070" ID="ID_88236918" MODIFIED="1591468248634" TEXT="p = 2 =&gt; k = 4"/>
<node CREATED="1591468249732" ID="ID_1301265527" MODIFIED="1591468373405">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      min(t[p][l], t[p][r - k + 1])
    </p>
    <p>
      min(t[2][2], t[2][4])
    </p>
    <p>
      min(1, 1)
    </p>
    <p>
      = 1
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
<node CREATED="1591468407363" ID="ID_43841173" MODIFIED="1591468425813" TEXT="Q: What is the minimum value between [3, 5]?">
<node CREATED="1591468443022" ID="ID_98164412" MODIFIED="1591468463041" TEXT="min(1, 1) = 1"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1591468493159" ID="ID_1009882679" MODIFIED="1591468500616" TEXT="Associative Function Queries">
<node CREATED="1591468502172" ID="ID_513338232" MODIFIED="1591468670944" TEXT="Some functions such as multiplication and summation are associative, but are not overlap friendly. A sparse table can still handle these types of queries, but in O(log_2(n)) rather than O(1). The main issue with non-overlap friendly functions with our previus approach is that overlapping intervals would yield the wrong answer.&#xa;&#xa;The alternative approach to performing a range query is to do a cascading query on the sparse table by breaking the range [l, r] into smaller ranges of size 2^x which do not overlap.&#xa;&#xa;For example, the range [2, 15] can be split into three intervals of lengths 8, 4 and 2:&#xa;= [2, 2 + 2^3) U [10, 10 + 2^2) U [14, 14 + 2^1)&#xa;= [2, 10) U [10, 14) U [14, 16)">
<node CREATED="1591491745988" ID="ID_661673416" MODIFIED="1591491761342" TEXT="Consider input array: [1, 2, -3, 2, 4, -1, 5]">
<node CREATED="1591491762733" ID="ID_884952421" MODIFIED="1591491790117" TEXT="Suppose we want to find the product of all the elements between [0, 6] using a sparse table. First, we would construct a table like we did before:">
<node CREATED="1591491791041" ID="ID_1991348610" MODIFIED="1591491824965">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      1 2 -3 2 4 -1 5
    </p>
    <p>
      2 -6 -6 8 -4 -5
    </p>
    <p>
      -12 -48 24 -40
    </p>
  </body>
</html>
</richcontent>
<node CREATED="1591491839475" ID="ID_416396248" MODIFIED="1591491878924" TEXT="Break interval [0, 6] into powers of 2: [0, 2^2) U [4, 4 + 2^1) U [6, 6 + 2^0)">
<node CREATED="1591491886716" ID="ID_1984777318" MODIFIED="1591491933805" TEXT="Lookup the value of each interval in the table and take the product of all the intervals: table[2][0] &amp; table[1][4] * table[0][6] = -12 * -4 * 5 = 240"/>
</node>
<node CREATED="1591491981799" ID="ID_1862844873" MODIFIED="1591492000262" TEXT="Q: What is the product of the interval [1, 5]?">
<node CREATED="1591492001480" ID="ID_133558866" MODIFIED="1591492022623" TEXT="Break interval [1, 5] into powers of 2: [1, 1 + 2^2) U [5, 5 + 2^0)">
<node CREATED="1591492023242" ID="ID_1471298289" MODIFIED="1591492058885" TEXT="Lookup the value of each interval in the table and tabke the product of all the intervals: table[2][1] * table[0][5] = -48 * -1 = 48"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1591492111892" ID="ID_425179947" MODIFIED="1591492115761" TEXT="Pseudocode">
<node CREATED="1591492117378" ID="ID_449386975" MODIFIED="1591492331058">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      # The number of elements in the input array
    </p>
    <p>
      N = ...
    </p>
    <p>
      
    </p>
    <p>
      # P, short for power. The largest 2^p that fits in N
    </p>
    <p>
      P = ... # calculated as: floor(log_2(N))
    </p>
    <p>
      
    </p>
    <p>
      # A quick lookup table for floor(log_2(i)), 1 &lt;= i &lt;= N
    </p>
    <p>
      log2 = ... # size N + 1, index 0 unused.
    </p>
    <p>
      
    </p>
    <p>
      # The sparse table containing integer values
    </p>
    <p>
      dp = ... # P + 1 rows and N columns
    </p>
    <p>
      
    </p>
    <p>
      # Index Table (IT) associated with the values in the
    </p>
    <p>
      # sparse table. This table is only useful when we want
    </p>
    <p>
      # to query the index of the min (or max) element in
    </p>
    <p>
      # the range [l, r] rather than the value itself.
    </p>
    <p>
      # The index table doesn't make sense for most other
    </p>
    <p>
      # range query types like gcd or sum.
    </p>
    <p>
      it = ... # P + 1 rows and N columns
    </p>
  </body>
</html>
</richcontent>
<node CREATED="1591492477135" ID="ID_1643620594" MODIFIED="1591492725687">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      function BuildMinSparseTable(values):
    </p>
    <p>
      &#160;&#160;N = length(values)
    </p>
    <p>
      &#160;&#160;P = floor(log(N) / log(2))
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;# Quick lookup table for floor(log_2(i)), 1 &lt;= 1 &lt;= N
    </p>
    <p>
      &#160;&#160;log2 = [0, 0, 0, ..., 0] # size N - 1
    </p>
    <p>
      &#160;&#160;for (i = 2, i &lt;= N; i++):
    </p>
    <p>
      &#160;&#160;&#160;&#160;log2[i] = log2[i / 2] + 1
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;# Fill first row
    </p>
    <p>
      &#160;&#160;for (i = 0; i &lt; N; i++):
    </p>
    <p>
      &#160;&#160;&#160;&#160;dp[0][i] = values[i]
    </p>
    <p>
      &#160;&#160;&#160;&#160;it[0][i] = i
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;for (p = 1; p &lt;= P; i++):
    </p>
    <p>
      &#160;&#160;&#160;&#160;for (i = 0; i + (1 &lt;&lt; p) &lt;= N; i++):
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;left = dp[p - 1][i]
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;right = dp[p - 1][i + (1 &lt;&lt; (p - 1))]
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dp[p][i] = min(left, right)
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;# Save/propagate the index of smallest element
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if left &lt;= right:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;it[p][i] = it[p - 1][i]
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;it[p][i] = it[p - 1][i + (1 &lt;&lt; (p - 1))]
    </p>
  </body>
</html>
</richcontent>
<node CREATED="1591492756163" ID="ID_1289284397" MODIFIED="1591492773700" TEXT="index table: keeps track of index values (a parallel structur) instead of min values"/>
</node>
<node CREATED="1591492781115" ID="ID_182213877" MODIFIED="1591492920753">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      # Query the smallest element in the range [l, r], O(1)
    </p>
    <p>
      function MinQuery(l, r):
    </p>
    <p>
      &#160;&#160;len = r - l + 1
    </p>
    <p>
      &#160;&#160;p = log2[len]
    </p>
    <p>
      &#160;&#160;left = dp[p][l]
    </p>
    <p>
      &#160;&#160;right = dp[p][r - ( 1 &lt;&lt; p) + 1]
    </p>
    <p>
      &#160;&#160;return min(left, right)
    </p>
    <p>
      
    </p>
    <p>
      # Query the smallest element in the range [l, r] by doing a
    </p>
    <p>
      # cascading min query, O(log_2(n)).
    </p>
    <p>
      function CascadingMinQuery(l, r):
    </p>
    <p>
      &#160;&#160;min_val = +inf
    </p>
    <p>
      &#160;&#160;for (p = log_2[r - l + 1]; l &lt;= r; p = log_2[r - l + 1]):
    </p>
    <p>
      &#160;&#160;&#160;&#160;min_val = min(min_val, dp[p][l])
    </p>
    <p>
      &#160;&#160;&#160;&#160;l += (1 &lt;&lt; p)
    </p>
    <p>
      &#160;&#160;return min_val
    </p>
  </body>
</html>
</richcontent>
</node>
<node CREATED="1591493010770" ID="ID_278682397" MODIFIED="1591493109078">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      # Returns in index of the minimum element in the range [l, r]
    </p>
    <p>
      # in the input values array. If there are multiple smallest
    </p>
    <p>
      # elements, the index of leftmost is returned.
    </p>
    <p>
      function MinIndexQuery(l, r):
    </p>
    <p>
      &#160;&#160;len = r - l + 1
    </p>
    <p>
      &#160;&#160;p = log2[len]
    </p>
    <p>
      &#160;&#160;left = dp[p][l]
    </p>
    <p>
      &#160;&#160;right = dp[p][r - (1 &lt;&lt; p) - 1]
    </p>
    <p>
      &#160;&#160;if left &lt;= right:
    </p>
    <p>
      &#160;&#160;&#160;&#160;return it[p][l]
    </p>
    <p>
      &#160;&#160;return it[p][r - (1 &lt;&lt; p) + 1]
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
</node>
</node>
<node CREATED="1567047990936" ID="ID_430826137" MODIFIED="1567047995764" POSITION="left" TEXT="Indexed Priority Queue">
<node CREATED="1567047996676" ID="ID_1465373898" MODIFIED="1567048021205" TEXT="Introduction to indexed priority queues">
<node CREATED="1579352716826" ID="ID_567228589" MODIFIED="1579352732189" TEXT="Recap"/>
<node CREATED="1579352740226" ID="ID_1341567466" MODIFIED="1579352747366" TEXT="What is an Indexed Priority Queue?">
<node CREATED="1579352758894" ID="ID_484731373" MODIFIED="1579352804508" TEXT="An Indexed Priority Queue is a traditional priority queue variant which on top of the regular PQ operations supports quick updates and deletions of key-value pairs.">
<node CREATED="1579352847170" ID="ID_885519984" MODIFIED="1579352865718" TEXT="Suppose a hospital has a waiting root with N people which need attention with different levels of priority">
<node CREATED="1579352870088" ID="ID_1988323736" MODIFIED="1579352879786" TEXT="Mary is in labour - Priority: 9">
<node CREATED="1579352970215" ID="ID_1736783784" MODIFIED="1579352973721" TEXT="Highest priority"/>
</node>
<node CREATED="1579352880263" ID="ID_691966819" MODIFIED="1579352893774" TEXT="Akarsh has a paper cut - Priority: 1">
<node CREATED="1579353061429" ID="ID_1340014318" MODIFIED="1579353081623" TEXT="+ open skull (fell on the floor in hospital) - Priority: 10"/>
</node>
<node CREATED="1579352894545" ID="ID_601456063" MODIFIED="1579352907056" TEXT="James has an arrow in his leg - Priority: 7"/>
<node CREATED="1579352907620" ID="ID_399337008" MODIFIED="1579352922052" TEXT="Naida&apos;s stomach hurts - Priority: 3">
<node CREATED="1579353006547" ID="ID_318149461" MODIFIED="1579353021308" TEXT="Suppose + vomiting - Priority: 6"/>
</node>
<node CREATED="1579352922413" ID="ID_1362473896" MODIFIED="1579352933943" TEXT="Richard has a fractured wrist - Priority: 5">
<node CREATED="1579353038148" ID="ID_858869294" MODIFIED="1579353048663" TEXT="Richard leaves and goes to another clinic"/>
</node>
<node CREATED="1579352934205" ID="ID_1339938582" MODIFIED="1579352945910" TEXT="Leah&apos;s stomach hurts - Priority: 3"/>
</node>
<node CREATED="1579353110725" ID="ID_941099019" MODIFIED="1579353116022" TEXT="Usefulness of IPQ">
<node CREATED="1579353168538" ID="ID_351139681" MODIFIED="1579353204744" TEXT="In the hospital example, we saw that it was very important to be able to dynamically update the priority (value) of certain people (keys).">
<node CREATED="1579353208805" ID="ID_1532092061" MODIFIED="1579353258531" TEXT="The Indexed Priority Queue (IPQ) data structure lets us do this efficiently The first step to using an IPQ is to assign index values to all the keys forming a bidirectional mapping">
<node CREATED="1579353326730" ID="ID_1801814980" MODIFIED="1579353351222" TEXT="Construct a bidirectional mapping between your N keys and the domain [0, N) using a bidirectional hashtable.">
<node CREATED="1579353352888" ID="ID_816692537" MODIFIED="1579353366880" TEXT="Key &lt;-&gt; Key Index (ki)">
<node CREATED="1579353369313" ID="ID_506655875" MODIFIED="1579353374689" TEXT="Mary &lt;-&gt; 0"/>
<node CREATED="1579353375002" ID="ID_1359361090" MODIFIED="1579353380025" TEXT="Akarsh &lt;-&gt; 1"/>
<node CREATED="1579353380265" ID="ID_379144029" MODIFIED="1579353384873" TEXT="James &lt;-&gt; 2"/>
<node CREATED="1579353385100" ID="ID_442645359" MODIFIED="1579353391057" TEXT="Naida &lt;-&gt; 3"/>
<node CREATED="1579353391295" ID="ID_1614780851" MODIFIED="1579353396545" TEXT="Richard &lt;-&gt; 4"/>
<node CREATED="1579353396810" ID="ID_1792324839" MODIFIED="1579353401408" TEXT="Leah &lt;-&gt; 5"/>
</node>
<node CREATED="1579353773771" ID="ID_825417000" MODIFIED="1579353801619" TEXT="NOTE: This assumes you know how many keys you will have in your IPQ, but this mapping can be constructed cynamically as well"/>
</node>
</node>
</node>
</node>
<node CREATED="1579353843165" ID="ID_293979139" MODIFIED="1579353846837" TEXT="Reason for mapping">
<node CREATED="1579353847693" ID="ID_892700928" MODIFIED="1579353865107" TEXT="Q: Why are we mapping keys to indexes in the domain [0, N)?">
<node CREATED="1579353867896" ID="ID_765132428" MODIFIED="1579353904522" TEXT="A: Typically priority queues are implemented as heaps under the hood which internally use arrays which we want to facilitate indexing into.">
<node CREATED="1579353907269" ID="ID_787346352" MODIFIED="1579353944203" TEXT="NOTE: Often the keys themselves are integers in the range [0, N) so there&apos;s no need for the mapping, but it&apos;s handy to be able to support any type of key (like names)."/>
</node>
</node>
</node>
<node CREATED="1579354001144" ID="ID_1352511749" MODIFIED="1579354005316" TEXT="IPQ ADT interface">
<node CREATED="1579354006369" ID="ID_332864976" MODIFIED="1579354033647" TEXT="If &apos;k&apos; is the key we want to update first get the key&apos;s index: ki = map[k], then use &apos;ki&apos; with the IPQ">
<node CREATED="1579354035606" ID="ID_1449285761" MODIFIED="1579354046044" TEXT="delete(ki)">
<node CREATED="1579363303597" ID="ID_1330830669" MODIFIED="1579363307166" TEXT="O(log(n))"/>
</node>
<node CREATED="1579354046369" ID="ID_1128503342" MODIFIED="1579354050667" TEXT="valueOf(ki)">
<node CREATED="1579363309727" ID="ID_604655440" MODIFIED="1579363311549" TEXT="O(1)"/>
</node>
<node CREATED="1579354051504" ID="ID_1150505900" MODIFIED="1579354055195" TEXT="contains(ki)">
<node CREATED="1579363314070" ID="ID_1612573116" MODIFIED="1579363316317" TEXT="O(1)"/>
</node>
<node CREATED="1579354056113" ID="ID_136879397" MODIFIED="1579354061123" TEXT="peekMinKeyIndex()">
<node CREATED="1579363318549" ID="ID_1484540501" MODIFIED="1579363320606" TEXT="O(1)"/>
</node>
<node CREATED="1579354061985" ID="ID_199943446" MODIFIED="1579354072444" TEXT="pollMinKeyIndex()">
<node CREATED="1579363323605" ID="ID_1069732998" MODIFIED="1579363327397" TEXT="O(log(n))"/>
</node>
<node CREATED="1579354072693" ID="ID_1831796570" MODIFIED="1579354078491" TEXT="peekMinValue()">
<node CREATED="1579363330195" ID="ID_634434001" MODIFIED="1579363333584" TEXT="O(1)"/>
</node>
<node CREATED="1579354078714" ID="ID_679048979" MODIFIED="1579354083060" TEXT="pollMinValue()">
<node CREATED="1579363338531" ID="ID_1431496679" MODIFIED="1579363341318" TEXT="O(log(n))"/>
</node>
<node CREATED="1579354084091" ID="ID_1208991343" MODIFIED="1579354088636" TEXT="insert(ki, value)">
<node CREATED="1579363343808" ID="ID_1672888653" MODIFIED="1579363348670" TEXT="O(log(n))"/>
</node>
<node CREATED="1579354088909" ID="ID_618778371" MODIFIED="1579354093012" TEXT="update(ki, value)">
<node CREATED="1579363349811" ID="ID_1091615891" MODIFIED="1579363352749" TEXT="O(log(n))"/>
</node>
<node CREATED="1579354093869" ID="ID_1958953611" MODIFIED="1579354100164" TEXT="decreaseKey(ki, value)">
<node CREATED="1579363354319" ID="ID_413363524" MODIFIED="1579363357677" TEXT="O(log(n))"/>
</node>
<node CREATED="1579354100770" ID="ID_164057649" MODIFIED="1579354107124" TEXT="increaseKey(ki, value)">
<node CREATED="1579363358850" ID="ID_1575164106" MODIFIED="1579363362678" TEXT="O(log(n))"/>
</node>
</node>
</node>
<node CREATED="1579363461316" ID="ID_1719164936" MODIFIED="1579363469878" TEXT="Refresher on binary heap DS">
<node CREATED="1579363470217" ID="ID_720434484" MODIFIED="1579363475717" TEXT="Let i be the current node">
<node CREATED="1579363476201" ID="ID_189399178" MODIFIED="1579363483279" TEXT="Left child index: 2i + 1"/>
<node CREATED="1579363483665" ID="ID_1367050776" MODIFIED="1579363488605" TEXT="Right child index: 2i + 2"/>
</node>
</node>
<node CREATED="1579363778312" ID="ID_401005470" MODIFIED="1579363828633" TEXT="Suppose we have N people with different priorities we need to serve. Assume priorities can dynamically change and we always want to serve the person with the lowest priority.">
<node CREATED="1579363840616" ID="ID_126206018" MODIFIED="1579363854617" TEXT="To figure out who to serve next use a Min IPQ to sort by lowest value first."/>
<node CREATED="1579363857878" ID="ID_1918727821" MODIFIED="1579363874369" TEXT="Arbitrarily assign each person a unique index value between [0, N)"/>
<node CREATED="1579363885627" ID="ID_1199473580" MODIFIED="1579363915720" TEXT="Initial values to place inside IPQ. These will be maintained by the IPQ once inserted. Note that values can be any comparable value not only integers">
<node CREATED="1579363973573" ID="ID_116791375" MODIFIED="1579363990980" TEXT="When we insert (ki, v) pairs into an IPQ we sort by the value associated with each key."/>
<node CREATED="1579363991756" ID="ID_1134592513" MODIFIED="1579364009602" TEXT="In the heap above we are sorting by smallest value since we&apos;re working with a min heap">
<node CREATED="1579364029602" ID="ID_1371259595" MODIFIED="1579364051414" TEXT="To access the value for any given key k, find its key index (ki) and do a lookup in the vals array maintained by the IPQ">
<node CREATED="1579364082263" ID="ID_1595305653" MODIFIED="1579364085833" TEXT="vals[ki]"/>
</node>
<node CREATED="1579364164327" ID="ID_1015082327" MODIFIED="1579364186456" TEXT="The array pm is a Position Map we maintain to tell us the index of the node in the heap for a given key index (ki)">
<node CREATED="1579364232250" ID="ID_687553884" MODIFIED="1579364235173" TEXT="pm[ki]"/>
</node>
<node CREATED="1579364318087" ID="ID_536372401" MODIFIED="1579364343062" TEXT="To do inverse lookup we also need to maintain an inverse lookup table denoted: im (Inverse Map)">
<node CREATED="1579364361119" ID="ID_154588954" MODIFIED="1579364376487" TEXT="Q: Which person (key) is represented in the node at index 2?">
<node CREATED="1579364515681" ID="ID_477981715" MODIFIED="1579364518505" TEXT="im[2]">
<node CREATED="1579364521424" ID="ID_378548442" MODIFIED="1579364524152" TEXT="return ki">
<node CREATED="1579364528145" ID="ID_1072984443" MODIFIED="1579364534023" TEXT="ki gives name"/>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1579364729499" ID="ID_984917488" MODIFIED="1579364736372" TEXT="Insertion">
<node CREATED="1579365022488" ID="ID_1743111531" MODIFIED="1579365030175" TEXT="Update vals, pm and im">
<node CREATED="1579365030922" ID="ID_95712922" MODIFIED="1579365044919" TEXT="If swap is done, swap values in pm and im"/>
</node>
<node CREATED="1579365067223" ID="ID_1559671449" MODIFIED="1579365073503" TEXT="Insertion Pseudo Code">
<node CREATED="1579365073820" ID="ID_144808172" MODIFIED="1579365152443">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      # Inserts a value into the min indexed binary
    </p>
    <p>
      # heap. The key index must not already be in
    </p>
    <p>
      # the heap and the value must not be null.
    </p>
    <p>
      function insert(ki, value):
    </p>
    <p>
      &#160;&#160;&#160;&#160;values[ki] = value
    </p>
    <p>
      &#160;&#160;&#160;&#160;# 'sz' is the current size of the heap
    </p>
    <p>
      &#160;&#160;&#160;&#160;pm[ki] = sz
    </p>
    <p>
      &#160;&#160;&#160;&#160;im[sz] = ki
    </p>
    <p>
      &#160;&#160;&#160;&#160;swim(sz)
    </p>
    <p>
      &#160;&#160;&#160;&#160;sz = sz + 1
    </p>
  </body>
</html></richcontent>
<node CREATED="1579365201377" ID="ID_1556529784" MODIFIED="1579365303602">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      # Swims up node i (zero based) until heap
    </p>
    <p>
      # invariant is satisfied.
    </p>
    <p>
      function swim(i):
    </p>
    <p>
      &#160;&#160;&#160;&#160;for (p = (i - 1) / 2; i &gt; 0 and less(i, p)):
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;swap(i, p)
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;i = p
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p = (i - 1) / 2
    </p>
    <p>
      
    </p>
    <p>
      function swap(i, j):
    </p>
    <p>
      &#160;&#160;&#160;&#160;pm[im[j]] = i
    </p>
    <p>
      &#160;&#160;&#160;&#160;pm[im[i]] = j
    </p>
    <p>
      &#160;&#160;&#160;&#160;tmp = im[i]
    </p>
    <p>
      &#160;&#160;&#160;&#160;im[i] = im[j]
    </p>
    <p>
      &#160;&#160;&#160;&#160;im[j] = tmp
    </p>
    <p>
      
    </p>
    <p>
      function less(i, j):
    </p>
    <p>
      &#160;&#160;&#160;&#160;return values[im[i]] &lt; values[im[j]]
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
</node>
<node CREATED="1579365429339" ID="ID_1024748883" MODIFIED="1579365436053" TEXT="Polling &amp; Removals">
<node CREATED="1579832618258" ID="ID_1238638412" MODIFIED="1579832683291" TEXT="Polling is still O(log(n)) in an IPQ, but removing is improved from O(n) in a traditional PQ to O(log(n)) since node position lookups are O(1) but repositioning is still O(log(n))">
<node CREATED="1579833030193" ID="ID_1684509511" MODIFIED="1579833082181" TEXT="Polling root node: The required steps are almost exactly like a regular binary heap">
<node CREATED="1579832918288" ID="ID_741751112" MODIFIED="1579832929768" TEXT="1. Exchange root node with bottom right node"/>
<node CREATED="1579832943439" ID="ID_194816796" MODIFIED="1579832968878" TEXT="2. Finally restore heap invariant by moving swapped purple node up or down"/>
</node>
</node>
<node CREATED="1579833234373" ID="ID_1577251238" MODIFIED="1579833242558" TEXT="Removing specific value &quot;Laura&quot;">
<node CREATED="1579833242953" ID="ID_547331170" MODIFIED="1579833248254" TEXT="Index is 11 (O(1))">
<node CREATED="1579833255512" ID="ID_1857376730" MODIFIED="1579833266685" TEXT="Swap with last node"/>
<node CREATED="1579833267780" ID="ID_160637979" MODIFIED="1579833275574" TEXT="Cleanup removed node"/>
<node CREATED="1579833276246" ID="ID_367675859" MODIFIED="1579833288496" TEXT="Restore heap invariant by moving swapping">
<node CREATED="1579833296917" ID="ID_950742993" MODIFIED="1579833300151" TEXT="O(log(n))"/>
</node>
</node>
<node CREATED="1579833322625" ID="ID_1734939650" MODIFIED="1579833326784" TEXT="Pseudo Code">
<node CREATED="1579833327040" ID="ID_900033708" MODIFIED="1579833473308">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      # Deletes the node with the key index ki
    </p>
    <p>
      # in the heap. The key index ki must exist
    </p>
    <p>
      # and be present in the heap.
    </p>
    <p>
      function remove(ki):
    </p>
    <p>
      &#160;&#160;&#160;&#160;i = pm[ki]
    </p>
    <p>
      &#160;&#160;&#160;&#160;swap(i, sz)
    </p>
    <p>
      &#160;&#160;&#160;&#160;sz = sz - 1
    </p>
    <p>
      &#160;&#160;&#160;&#160;sink(i)
    </p>
    <p>
      &#160;&#160;&#160;&#160;swim(i)
    </p>
    <p>
      &#160;&#160;&#160;&#160;values[ki] = null
    </p>
    <p>
      &#160;&#160;&#160;&#160;pm[ki] = -1
    </p>
    <p>
      &#160;&#160;&#160;&#160;im[sz] = -1
    </p>
  </body>
</html></richcontent>
<node CREATED="1579833443466" ID="ID_1190426241" MODIFIED="1579833445818" TEXT="sz = size"/>
<node CREATED="1579833476372" ID="ID_502328078" MODIFIED="1579833493780" TEXT="sink or swim needs to be done (we are not sure)"/>
<node CREATED="1579833502010" ID="ID_746839747" MODIFIED="1579833594405">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      # Sinks the node at index i by swapping
    </p>
    <p>
      # itself with the smallest of the left
    </p>
    <p>
      # or the right child node.
    </p>
    <p>
      function sink(i):
    </p>
    <p>
      &#160;&#160;&#160;&#160;while true:
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;left = 2 * i + 1
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;right = 2 * i + 2
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;smallest = left
    </p>
    <p>
      &#160;&#160;&#160;
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if right &lt; sz and less(right, left):
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;smallest = right
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if left &gt;= sz or less(i, smallest):
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break
    </p>
    <p>
      
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;swap(smallest, i)
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;i = smallest
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1579833652477" ID="ID_1344945459" MODIFIED="1579833654624" TEXT="Updates">
<node CREATED="1579833658215" ID="ID_354424947" MODIFIED="1579833700449" TEXT="Similar to removals, updates in a min indexed binary heap also take O(log(n)) due to O(1) lookup time to find the node and O(log(n)) time to adjust where the key-value pair should appear in the heap">
<node CREATED="1579833759488" ID="ID_1866672772" MODIFIED="1579833764970" TEXT="Pseudo Code">
<node CREATED="1579833765346" ID="ID_1269000186" MODIFIED="1579833814090">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      # Updates the value of a key in the binary
    </p>
    <p>
      # heap. The key index must exist and the
    </p>
    <p>
      # value must not be null.
    </p>
    <p>
      function update(ki, value):
    </p>
    <p>
      &#160;&#160;&#160;&#160;i = pm[ki]
    </p>
    <p>
      &#160;&#160;&#160;&#160;values[ki] = value
    </p>
    <p>
      &#160;&#160;&#160;&#160;sink(i)
    </p>
    <p>
      &#160;&#160;&#160;&#160;swim(i)
    </p>
  </body>
</html></richcontent>
<node CREATED="1579833828307" ID="ID_1967965885" MODIFIED="1579833833508" TEXT="Decrease and Increase key">
<node CREATED="1579833834924" ID="ID_1200869825" MODIFIED="1579833919782" TEXT="In many applications (e.g Dijkstra&apos;s and Prims algorithm) it is often useful to only update a given key to make its value either always smaller (or larger). In the event that a worse value is given the value in the IPQ should not be updated.&#xa;&#xa;In such situations it is useful to define a more restrictive form of update operation we call increaseKey(ki, v) and decreaseKey(ki, v)">
<node CREATED="1579834130089" ID="ID_954784077" MODIFIED="1579834133963" TEXT="Pseudo Code">
<node CREATED="1579834134331" ID="ID_1552400065" MODIFIED="1579834223630">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      # For both these functions assume ki and value
    </p>
    <p>
      # are valid inputs and we are dealing with a
    </p>
    <p>
      # min indexed binary heap
    </p>
    <p>
      function decreaseKey(ki, value):
    </p>
    <p>
      &#160;&#160;&#160;&#160;if less(value, values[ki]):
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;values[ki] = value
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;swim(pm[ki])
    </p>
    <p>
      
    </p>
    <p>
      function increaseKey(ki, value):
    </p>
    <p>
      &#160;&#160;&#160;&#160;if less(values[ki], value):
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;values[ki] = value
    </p>
    <p>
      &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sink(pm[ki])
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
</node>
<node CREATED="1567048022793" ID="ID_526212390" MODIFIED="1567048028448" TEXT="Indexed priority queue source code"/>
</node>
</node>
</map>
